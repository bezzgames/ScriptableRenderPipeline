%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &114023846229194376
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 73a13919d81fb7444849bae8b5c812a2, type: 3}
  m_Name: VFXBasicSpawner
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614572}
  m_UIPosition: {x: 702, y: -125}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 0}
  m_InputFlowSlot:
  - link: []
  - link: []
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 114946465509916290}
      slotIndex: 0
--- !u!114 &114131763552434164
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: SetAttribute
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114946465509916290}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614571}
  m_OutputSlots: []
  m_Disabled: 1
  attribute: lifetime
  Composition: 0
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &114307113894698210
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 1b605c022ee79394a8a776c0869b3f9a, type: 3}
  m_Name: VFXSlot
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 114986932069951040}
  - {fileID: 114963171269329408}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 114946465509916290}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.AABox, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"center":{"x":0.0,"y":1.0,"z":0.0},"size":{"x":2.0,"y":3.0,"z":2.0}}'
    m_Space: 0
  m_Property:
    name: bounds
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.AABox, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114340500867371532
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d01270efd3285ea4a9d6c555cb0a8027, type: 3}
  m_Name: VFXUI
  m_EditorClassIdentifier: 
  groupInfos: []
  stickyNoteInfos: []
  systemInfos: []
  categories: []
  uiBounds:
    serializedVersion: 2
    x: 195
    y: -172
    width: 3733
    height: 1652
--- !u!114 &114350483966674976
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7d4c867f6b72b714dbb5fd1780afe208, type: 3}
  m_Name: HDRPlit
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 114023846229194376}
  - {fileID: 114946465509916290}
  - {fileID: 114780028408030698}
  - {fileID: 8926484042661614554}
  - {fileID: 8926484042661614583}
  - {fileID: 8926484042661614587}
  - {fileID: 8926484042661614593}
  - {fileID: 8926484042661614601}
  - {fileID: 8926484042661614611}
  - {fileID: 8926484042661614615}
  - {fileID: 8926484042661614719}
  - {fileID: 8926484042661614621}
  - {fileID: 8926484042661614629}
  - {fileID: 8926484042661614639}
  - {fileID: 8926484042661614667}
  - {fileID: 8926484042661614669}
  - {fileID: 8926484042661614680}
  - {fileID: 8926484042661614695}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_UIInfos: {fileID: 114340500867371532}
  m_ParameterInfo: []
  m_GraphVersion: 2
  m_saved: 1
  m_SubgraphDependencies: []
  m_CategoryPath: 
--- !u!114 &114380859405582094
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114963171269329408}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114428730288789306
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d78581a96eae8bf4398c282eb0b098bd, type: 3}
  m_Name: VFXDataParticle
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  title: 
  m_Owners:
  - {fileID: 114946465509916290}
  - {fileID: 114780028408030698}
  - {fileID: 8926484042661614554}
  - {fileID: 8926484042661614593}
  - {fileID: 8926484042661614601}
  - {fileID: 8926484042661614680}
  m_Capacity: 2
  m_Space: 0
--- !u!114 &114512514798047786
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114963171269329408}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114538391275492396
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114986932069951040}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114739294351936256
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114986932069951040}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114780028408030698
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2dc095764ededfa4bb32fa602511ea4b, type: 3}
  m_Name: VFXBasicUpdate
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614581}
  m_UIPosition: {x: 709, y: 776}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114946465509916290}
      slotIndex: 0
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614554}
      slotIndex: 0
    - context: {fileID: 8926484042661614593}
      slotIndex: 0
    - context: {fileID: 8926484042661614601}
      slotIndex: 0
    - context: {fileID: 8926484042661614680}
      slotIndex: 0
  integration: 0
  angularIntegration: 0
  ageParticles: 1
  reapParticles: 1
--- !u!114 &114920711487922656
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114963171269329408}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114935892456706286
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114986932069951040}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114946465509916290
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 9dfea48843f53fc438eabc12a3a30abc, type: 3}
  m_Name: VFXBasicInitialize
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 114131763552434164}
  - {fileID: 8926484042661614556}
  - {fileID: 8926484042661614569}
  m_UIPosition: {x: 708, y: 178}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 114307113894698210}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114023846229194376}
      slotIndex: 0
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
--- !u!114 &114963171269329408
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: VFXSlotFloat3
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114307113894698210}
  m_Children:
  - {fileID: 114512514798047786}
  - {fileID: 114920711487922656}
  - {fileID: 114380859405582094}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: size
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The size of the box along each axis.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114986932069951040
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: VFXSlotFloat3
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114307113894698210}
  m_Children:
  - {fileID: 114739294351936256}
  - {fileID: 114935892456706286}
  - {fileID: 114538391275492396}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: center
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The centre of the box.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!2058629511 &8926484042661614527
VisualEffectResource:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: HDRPlit
  m_Graph: {fileID: 114350483966674976}
  m_ShaderSources:
  - compute: 1
    name: '[System 1]Initialize'
    source: "#pragma kernel CSMain\n#define NB_THREADS_PER_GROUP 64\n#define VFX_USE_PARTICLEID_CURRENT
      1\n#define VFX_USE_POSITION_CURRENT 1\n#define VFX_USE_SIZE_CURRENT 1\n#define
      VFX_USE_ANGLEX_CURRENT 1\n#define VFX_LOCAL_SPACE 1\n#include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n\n\n\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/Common/VFXCommonCompute.cginc\"\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n\n\n\nRWByteAddressBuffer
      attributeBuffer;\nByteAddressBuffer sourceAttributeBuffer;\n\nCBUFFER_START(initParams)\n#if
      !VFX_USE_SPAWNER_FROM_GPU\n    uint nbSpawned;\t\t\t\t\t// Numbers of particle
      spawned\n    uint spawnIndex;\t\t\t\t// Index of the first particle spawned\n   
      uint dispatchWidth;\n#else\n    uint offsetInAdditionalOutput;\n\tuint nbMax;\n#endif\n\tuint
      systemSeed;\nCBUFFER_END\n\n#if VFX_USE_ALIVE_CURRENT\nRWStructuredBuffer<uint>
      deadListIn;\nByteAddressBuffer deadListCount; // This is bad to use a SRV to
      fetch deadList count but Unity API currently prevent from copying to CB\n#endif\n\n#if
      VFX_USE_SPAWNER_FROM_GPU\nStructuredBuffer<uint> eventList;\nByteAddressBuffer
      inputAdditional;\n#endif\n\nvoid PositionSequential_267A9(uint particleId,
      inout float3 position, float3 computedPosition) /*shape:Line index:ParticleID
      writePosition:True writeTargetPosition:False mode:Wrap */\n{\n    position
      += computedPosition;\n    \n}\nvoid SetAttribute_3278B22F(inout float size,
      float Size) /*attribute:size Composition:Overwrite Source:Slot Random:Off channels:XYZ
      */\n{\n    size = Size;\n}\n\n\n\n[numthreads(NB_THREADS_PER_GROUP,1,1)]\nvoid
      CSMain(uint3 groupId          : SV_GroupID,\n            uint3 groupThreadId   
      : SV_GroupThreadID)\n{\n    uint id = groupThreadId.x + groupId.x * NB_THREADS_PER_GROUP;\n#if
      !VFX_USE_SPAWNER_FROM_GPU\n    id += groupId.y * dispatchWidth * NB_THREADS_PER_GROUP;\n#endif\n\n#if
      VFX_USE_SPAWNER_FROM_GPU\n    uint maxThreadId = inputAdditional.Load((offsetInAdditionalOutput
      * 2 + 0) << 2);\n    uint currentSpawnIndex = inputAdditional.Load((offsetInAdditionalOutput
      * 2 + 1) << 2) - maxThreadId;\n#else\n    uint maxThreadId = nbSpawned;\n   
      uint currentSpawnIndex = spawnIndex;\n#endif\n\n#if VFX_USE_ALIVE_CURRENT\n   
      maxThreadId = min(maxThreadId, deadListCount.Load(0x0));\n#elif VFX_USE_SPAWNER_FROM_GPU\n   
      maxThreadId = min(maxThreadId, nbMax); //otherwise, nbSpawned already clamped
      on CPU\n#endif\n\n    if (id < maxThreadId)\n    {\n#if VFX_USE_SPAWNER_FROM_GPU\n       
      int sourceIndex = eventList[id];\n#endif\n        uint particleIndex = id +
      currentSpawnIndex;\n\t\t\n#if !VFX_USE_SPAWNER_FROM_GPU\n        int sourceIndex
      = 0;\n        /*//Loop with 1 iteration generate a wrong IL Assembly (and actually,
      useless code)\n        uint currentSumSpawnCount = 0u;\n        for (sourceIndex=0;
      sourceIndex<1; sourceIndex++)\n        {\n            currentSumSpawnCount
      += uint(asfloat(sourceAttributeBuffer.Load((sourceIndex * 0x1 + 0x0) << 2)));\n           
      if (id < currentSumSpawnCount)\n            {\n                break;\n           
      }\n        }\n        */\n        \n\n#endif\n        uint particleId = (uint)0;\n       
      float3 position = float3(0,0,0);\n        float size = (float)0.1;\n       
      float angleX = (float)0;\n        \n\n#if VFX_USE_PARTICLEID_CURRENT\n        
      particleId = particleIndex;\n#endif\n#if VFX_USE_SEED_CURRENT\n        seed
      = WangHash(particleIndex ^ systemSeed);\n#endif\n        \n        {\n           
      uint tmp_t = particleId / (uint)2;\n            uint tmp_u = tmp_t * (uint)2;\n           
      uint tmp_v = particleId - tmp_u;\n            float tmp_w = (float)tmp_v;\n           
      float3 tmp_x = float3(tmp_w, tmp_w, tmp_w);\n            float3 tmp_z = tmp_x
      * float3(2,0,0);\n            PositionSequential_267A9(particleId,  /*inout
      */position, tmp_z);\n        }\n        {\n            SetAttribute_3278B22F(
      /*inout */size, (float)1.67);\n        }\n        \n\n\n#if VFX_USE_ALIVE_CURRENT\n       
      if (alive)\n        {\n\t\t\tuint deadIndex = deadListIn.DecrementCounter();\n           
      uint index = deadListIn[deadIndex];\n            attributeBuffer.Store((index
      * 0x1 + 0x0) << 2,asuint(particleId));\n            attributeBuffer.Store3((index
      * 0x4 + 0x4) << 2,asuint(position));\n            attributeBuffer.Store((index
      * 0x4 + 0x7) << 2,asuint(size));\n            attributeBuffer.Store((index
      * 0x1 + 0x14) << 2,asuint(angleX));\n            \n\n        }\n#else\n       
      uint index = particleIndex;\n        attributeBuffer.Store((index * 0x1 + 0x0)
      << 2,asuint(particleId));\n        attributeBuffer.Store3((index * 0x4 + 0x4)
      << 2,asuint(position));\n        attributeBuffer.Store((index * 0x4 + 0x7)
      << 2,asuint(size));\n        attributeBuffer.Store((index * 0x1 + 0x14) <<
      2,asuint(angleX));\n        \n\n#endif\n    }\n}\n"
  - compute: 1
    name: '[System 1]Update'
    source: "#pragma kernel CSMain\n#define NB_THREADS_PER_GROUP 64\n#define VFX_USE_PARTICLEID_CURRENT
      1\n#define VFX_USE_ANGLEX_CURRENT 1\n#define VFX_LOCAL_SPACE 1\n#include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n\n\n\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/Common/VFXCommonCompute.cginc\"\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n\n\n\nRWByteAddressBuffer
      attributeBuffer;\n\n#if VFX_USE_ALIVE_CURRENT\nRWStructuredBuffer<uint> deadListOut;\n#endif\n\n#if
      VFX_HAS_INDIRECT_DRAW\nRWStructuredBuffer<uint> indirectBuffer;\n#endif\n\nCBUFFER_START(updateParams)\n   
      uint nbMax;\n\tuint dispatchWidth;\n\tuint systemSeed;\nCBUFFER_END\n\nvoid
      SetAttribute_48A7BEF9(inout float angleX, float Angle) /*attribute:angle Composition:Overwrite
      Source:Slot Random:Off channels:X */\n{\n    angleX = Angle.x;\n}\n\n\n\n[numthreads(NB_THREADS_PER_GROUP,1,1)]\nvoid
      CSMain(uint3 groupId          : SV_GroupID,\n            uint3 groupThreadId   
      : SV_GroupThreadID)\n{\n\tuint id = groupThreadId.x + groupId.x * NB_THREADS_PER_GROUP
      + groupId.y * dispatchWidth * NB_THREADS_PER_GROUP;\n\tuint index = id;\n\tif
      (id < nbMax)\n\t{\n#if VFX_USE_ALIVE_CURRENT\n\t\t\n\t\tif (alive)\n\t\t{\n\t\t\tuint
      particleId = (attributeBuffer.Load((index * 0x1 + 0x0) << 2));\n\t\t\tfloat
      angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n\t\t\t\n\n\t\t\t\n#if
      VFX_USE_OLDPOSITION_CURRENT\n\t\t\toldPosition = position;\n#endif\n\t\t\t\n\t\t\t{\n\t\t\t   
      float tmp_s = (float)particleId;\n\t\t\t    float tmp_u = tmp_s * (float)23;\n\t\t\t   
      SetAttribute_48A7BEF9( /*inout */angleX, tmp_u);\n\t\t\t}\n\t\t\t\n\n\t\t\tif
      (alive)\n\t\t\t{\n\t\t\t\tattributeBuffer.Store((index * 0x1 + 0x14) << 2,asuint(angleX));\n\t\t\t\t\n\n#if
      VFX_HAS_INDIRECT_DRAW\n                uint indirectIndex = indirectBuffer.IncrementCounter();\n\t\t\t\tindirectBuffer[indirectIndex]
      = index;\n#endif\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tuint deadIndex
      = deadListOut.IncrementCounter();\n\t\t\t\tdeadListOut[deadIndex] = index;\n\t\t\t}\n\t\t}\n#else\n\t\tuint
      particleId = (attributeBuffer.Load((index * 0x1 + 0x0) << 2));\n\t\tfloat angleX
      = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n\t\t\n\n\t\t\n#if
      VFX_USE_OLDPOSITION_CURRENT\n\t\toldPosition = position;\n#endif\n\t\t\n\t\t{\n\t\t   
      float tmp_s = (float)particleId;\n\t\t    float tmp_u = tmp_s * (float)23;\n\t\t   
      SetAttribute_48A7BEF9( /*inout */angleX, tmp_u);\n\t\t}\n\t\t\n\n\t\tattributeBuffer.Store((index
      * 0x1 + 0x14) << 2,asuint(angleX));\n\t\t\n\n#if VFX_HAS_INDIRECT_DRAW\n       
      uint indirectIndex = indirectBuffer.IncrementCounter();\n\t\tindirectBuffer[indirectIndex]
      = index;\n#endif\n#endif\n\t}\n}\n"
  - compute: 0
    name: '[System 1]Shader Graph Quad Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 1/Shader Graph Quad Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      surface.Albedo = IsGammaSpace() ? float3(0.7353569, 0.7353569, 0.7353569) :
      SRGBToLinear(float3(0.7353569, 0.7353569, 0.7353569));\n                                   
      surface.Normal = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 0;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthOnly\"\n           
      Tags {\"LightMode\" = \"DepthOnly\" }\n            Cull Back\n            ZWrite
      On\n            Stencil\n            {\n                WriteMask 48\n               
      Ref 0\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      surface.Normal = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"GBuffer\"\n           
      Tags {\"LightMode\" = \"GBuffer\" }\n            Cull Back\n            ZTest
      LEqual\n            Stencil\n            {\n                WriteMask 51\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_GBUFFER\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      _ LIGHT_LAYERS\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      surface.Albedo = IsGammaSpace() ? float3(0.7353569, 0.7353569, 0.7353569) :
      SRGBToLinear(float3(0.7353569, 0.7353569, 0.7353569));\n                                   
      surface.Normal = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 0;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassGBuffer.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            Stencil\n            {\n                WriteMask 176\n               
      Ref 128\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      surface.Normal = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"Forward\"\n           
      Tags {\"LightMode\" = \"Forward\" }\n            Cull Back\n            ZTest
      Equal\n            ZWrite On\n            ColorMask RGBA 1\n            Blend
      One Zero, One Zero\n            Stencil\n            {\n                WriteMask
      3\n                Ref 2\n                Comp Always\n                Pass
      Replace\n            }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n                            #pragma
      multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      surface.Albedo = IsGammaSpace() ? float3(0.7353569, 0.7353569, 0.7353569) :
      SRGBToLinear(float3(0.7353569, 0.7353569, 0.7353569));\n                                   
      surface.Normal = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 0;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 1]Shader Graph Quad Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 1/Shader Graph Quad Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.CottonWool\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Specular\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float3 Specular;\n                                    float3 Emission;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_21A3DC61_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_21A3DC61_Texture_1,
      sampler_SampleTexture2D_21A3DC61_Texture_1, IN.uv0.xy);\n                                   
      float _SampleTexture2D_21A3DC61_R_4 = _SampleTexture2D_21A3DC61_RGBA_0.r;\n                                   
      float _SampleTexture2D_21A3DC61_G_5 = _SampleTexture2D_21A3DC61_RGBA_0.g;\n                                   
      float _SampleTexture2D_21A3DC61_B_6 = _SampleTexture2D_21A3DC61_RGBA_0.b;\n                                   
      float _SampleTexture2D_21A3DC61_A_7 = _SampleTexture2D_21A3DC61_RGBA_0.a;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      surface.Albedo = (_SampleTexture2D_21A3DC61_RGBA_0.xyz);\n                                   
      surface.Normal = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Specular = IsGammaSpace()
      ? float3(0.2, 0.2, 0.2) : SRGBToLinear(float3(0.2, 0.2, 0.2));\n                                   
      surface.Emission = float3(0, 0, 0);\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.48,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.CottonWool\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      // surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.48,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      Blend One Zero\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.CottonWool\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      // surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.48,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            Cull Back\n           
      ZWrite On\n            Stencil\n            {\n                WriteMask 48\n               
      Ref 0\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.CottonWool\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      surface.Normal = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.48,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      Stencil\n            {\n                WriteMask 176\n                Ref
      128\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.CottonWool\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      surface.Normal = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.48,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ForwardOnly\"\n           
      Tags {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n           
      ZWrite On\n            Blend One Zero, One Zero\n            Stencil\n           
      {\n                WriteMask 3\n                Ref 2\n                Comp
      Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                        #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _DOUBLESIDED_ON\n                        #pragma shader_feature_local _ _BLENDMODE_ALPHA
      _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n                            #pragma
      multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.CottonWool\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Specular\n                            //   SurfaceDescription.Emission\n                           
      //   SurfaceDescription.Alpha\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   AttributesMesh.uv3\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord0\n                            //   FragInputs.texCoord1\n                           
      //   FragInputs.texCoord2\n                            //   FragInputs.texCoord3\n                           
      //   FragInputs.color\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   VaryingsMeshToPS.texCoord1\n                           
      //   VaryingsMeshToPS.texCoord2\n                            //   VaryingsMeshToPS.texCoord3\n                           
      //   VaryingsMeshToPS.color\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define VARYINGS_NEED_TEXCOORD0\n                       
      #define VARYINGS_NEED_TEXCOORD1\n                        #define VARYINGS_NEED_TEXCOORD2\n                       
      #define VARYINGS_NEED_TEXCOORD3\n                        #define VARYINGS_NEED_COLOR\n                       
      // #define VARYINGS_NEED_CULLFACE\n                        // #define HAVE_MESH_MODIFICATION\n                   
      \n                    // We need isFontFace when using double sided\n                   
      #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n                       
      #define VARYINGS_NEED_CULLFACE\n                    #endif\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float Smoothness;\n                                   
      float Occlusion;\n                                    float3 Specular;\n                                   
      float3 Emission;\n                                    float Alpha;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n            ByteAddressBuffer attributeBuffer;\n           
      SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS
      vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_21A3DC61_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_21A3DC61_Texture_1,
      sampler_SampleTexture2D_21A3DC61_Texture_1, IN.uv0.xy);\n                                   
      float _SampleTexture2D_21A3DC61_R_4 = _SampleTexture2D_21A3DC61_RGBA_0.r;\n                                   
      float _SampleTexture2D_21A3DC61_G_5 = _SampleTexture2D_21A3DC61_RGBA_0.g;\n                                   
      float _SampleTexture2D_21A3DC61_B_6 = _SampleTexture2D_21A3DC61_RGBA_0.b;\n                                   
      float _SampleTexture2D_21A3DC61_A_7 = _SampleTexture2D_21A3DC61_RGBA_0.a;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      surface.Albedo = (_SampleTexture2D_21A3DC61_RGBA_0.xyz);\n                                   
      surface.Normal = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Specular = IsGammaSpace()
      ? float3(0.2, 0.2, 0.2) : SRGBToLinear(float3(0.2, 0.2, 0.2));\n                                   
      surface.Emission = float3(0, 0, 0);\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.48,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 1]Shader Graph Mesh Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 1/Shader Graph Mesh Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   CoatMask\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Voronoi_2A1D40B5_Out_3;\n                                    float _Voronoi_2A1D40B5_Cells_4;\n                                   
      Unity_Voronoi_float(IN.uv0.xy, 2, 17.66, _Voronoi_2A1D40B5_Out_3, _Voronoi_2A1D40B5_Cells_4);\n                                   
      surface.Albedo = (_Voronoi_2A1D40B5_Cells_4.xxx);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 1;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.18,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.18,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.18,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthOnly\"\n           
      Tags {\"LightMode\" = \"DepthOnly\" }\n            Cull Back\n            ZWrite
      On\n            Stencil\n            {\n                WriteMask 48\n               
      Ref 0\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Alpha\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   AttributesMesh.uv3\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord0\n                            //   FragInputs.texCoord1\n                           
      //   FragInputs.texCoord2\n                            //   FragInputs.texCoord3\n                           
      //   FragInputs.color\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   VaryingsMeshToPS.texCoord1\n                           
      //   VaryingsMeshToPS.texCoord2\n                            //   VaryingsMeshToPS.texCoord3\n                           
      //   VaryingsMeshToPS.color\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define VARYINGS_NEED_TEXCOORD0\n                       
      #define VARYINGS_NEED_TEXCOORD1\n                        #define VARYINGS_NEED_TEXCOORD2\n                       
      #define VARYINGS_NEED_TEXCOORD3\n                        #define VARYINGS_NEED_COLOR\n                       
      // #define VARYINGS_NEED_CULLFACE\n                        // #define HAVE_MESH_MODIFICATION\n                   
      \n                    // We need isFontFace when using double sided\n                   
      #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n                       
      #define VARYINGS_NEED_CULLFACE\n                    #endif\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.18,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"GBuffer\"\n           
      Tags {\"LightMode\" = \"GBuffer\" }\n            Cull Back\n            ZTest
      LEqual\n            Stencil\n            {\n                WriteMask 51\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_GBUFFER\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      _ LIGHT_LAYERS\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   Specular.EnergyConserving\n                           
      //   CoatMask\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Voronoi_2A1D40B5_Out_3;\n                                    float _Voronoi_2A1D40B5_Cells_4;\n                                   
      Unity_Voronoi_float(IN.uv0.xy, 2, 17.66, _Voronoi_2A1D40B5_Out_3, _Voronoi_2A1D40B5_Cells_4);\n                                   
      surface.Albedo = (_Voronoi_2A1D40B5_Cells_4.xxx);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 1;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassGBuffer.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.18,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            Stencil\n            {\n                WriteMask 176\n               
      Ref 128\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Alpha\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   AttributesMesh.uv3\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord0\n                            //   FragInputs.texCoord1\n                           
      //   FragInputs.texCoord2\n                            //   FragInputs.texCoord3\n                           
      //   FragInputs.color\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   VaryingsMeshToPS.texCoord1\n                           
      //   VaryingsMeshToPS.texCoord2\n                            //   VaryingsMeshToPS.texCoord3\n                           
      //   VaryingsMeshToPS.color\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define VARYINGS_NEED_TEXCOORD0\n                       
      #define VARYINGS_NEED_TEXCOORD1\n                        #define VARYINGS_NEED_TEXCOORD2\n                       
      #define VARYINGS_NEED_TEXCOORD3\n                        #define VARYINGS_NEED_COLOR\n                       
      // #define VARYINGS_NEED_CULLFACE\n                        // #define HAVE_MESH_MODIFICATION\n                   
      \n                    // We need isFontFace when using double sided\n                   
      #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n                       
      #define VARYINGS_NEED_CULLFACE\n                    #endif\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.18,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"Forward\"\n           
      Tags {\"LightMode\" = \"Forward\" }\n            Cull Back\n            ZTest
      Equal\n            ZWrite On\n            ColorMask RGBA 1\n            Blend
      One Zero, One Zero\n            Stencil\n            {\n                WriteMask
      3\n                Ref 2\n                Comp Always\n                Pass
      Replace\n            }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define
      _AMBIENT_OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _HAS_REFRACTION 1\n                       
      // #define _REFRACTION_PLANE 1\n                        // #define _REFRACTION_SPHERE
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR
      1\n                        // #define _DEPTHOFFSET_ON 1\n                       
      // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n                            #pragma
      multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   Specular.EnergyConserving\n                            //   CoatMask\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Voronoi_2A1D40B5_Out_3;\n                                    float _Voronoi_2A1D40B5_Cells_4;\n                                   
      Unity_Voronoi_float(IN.uv0.xy, 2, 17.66, _Voronoi_2A1D40B5_Out_3, _Voronoi_2A1D40B5_Cells_4);\n                                   
      surface.Albedo = (_Voronoi_2A1D40B5_Cells_4.xxx);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 1;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.18,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 1
    name: '[System 2]Update'
    source: "#pragma kernel CSMain\n#define NB_THREADS_PER_GROUP 64\n#define VFX_USE_PARTICLEID_CURRENT
      1\n#define VFX_USE_ANGLEX_CURRENT 1\n#define VFX_LOCAL_SPACE 1\n#include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n\n\n\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/Common/VFXCommonCompute.cginc\"\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n\n\n\nRWByteAddressBuffer
      attributeBuffer;\n\n#if VFX_USE_ALIVE_CURRENT\nRWStructuredBuffer<uint> deadListOut;\n#endif\n\n#if
      VFX_HAS_INDIRECT_DRAW\nRWStructuredBuffer<uint> indirectBuffer;\n#endif\n\nCBUFFER_START(updateParams)\n   
      uint nbMax;\n\tuint dispatchWidth;\n\tuint systemSeed;\nCBUFFER_END\n\nvoid
      SetAttribute_48A7BEF9(inout float angleX, float Angle) /*attribute:angle Composition:Overwrite
      Source:Slot Random:Off channels:X */\n{\n    angleX = Angle.x;\n}\n\n\n\n[numthreads(NB_THREADS_PER_GROUP,1,1)]\nvoid
      CSMain(uint3 groupId          : SV_GroupID,\n            uint3 groupThreadId   
      : SV_GroupThreadID)\n{\n\tuint id = groupThreadId.x + groupId.x * NB_THREADS_PER_GROUP
      + groupId.y * dispatchWidth * NB_THREADS_PER_GROUP;\n\tuint index = id;\n\tif
      (id < nbMax)\n\t{\n#if VFX_USE_ALIVE_CURRENT\n\t\t\n\t\tif (alive)\n\t\t{\n\t\t\tuint
      particleId = (attributeBuffer.Load((index * 0x1 + 0x0) << 2));\n\t\t\tfloat
      angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n\t\t\t\n\n\t\t\t\n#if
      VFX_USE_OLDPOSITION_CURRENT\n\t\t\toldPosition = position;\n#endif\n\t\t\t\n\t\t\t{\n\t\t\t   
      float tmp_s = (float)particleId;\n\t\t\t    float tmp_u = tmp_s * (float)23;\n\t\t\t   
      SetAttribute_48A7BEF9( /*inout */angleX, tmp_u);\n\t\t\t}\n\t\t\t\n\n\t\t\tif
      (alive)\n\t\t\t{\n\t\t\t\tattributeBuffer.Store((index * 0x1 + 0x14) << 2,asuint(angleX));\n\t\t\t\t\n\n#if
      VFX_HAS_INDIRECT_DRAW\n                uint indirectIndex = indirectBuffer.IncrementCounter();\n\t\t\t\tindirectBuffer[indirectIndex]
      = index;\n#endif\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tuint deadIndex
      = deadListOut.IncrementCounter();\n\t\t\t\tdeadListOut[deadIndex] = index;\n\t\t\t}\n\t\t}\n#else\n\t\tuint
      particleId = (attributeBuffer.Load((index * 0x1 + 0x0) << 2));\n\t\tfloat angleX
      = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n\t\t\n\n\t\t\n#if
      VFX_USE_OLDPOSITION_CURRENT\n\t\toldPosition = position;\n#endif\n\t\t\n\t\t{\n\t\t   
      float tmp_s = (float)particleId;\n\t\t    float tmp_u = tmp_s * (float)23;\n\t\t   
      SetAttribute_48A7BEF9( /*inout */angleX, tmp_u);\n\t\t}\n\t\t\n\n\t\tattributeBuffer.Store((index
      * 0x1 + 0x14) << 2,asuint(angleX));\n\t\t\n\n#if VFX_HAS_INDIRECT_DRAW\n       
      uint indirectIndex = indirectBuffer.IncrementCounter();\n\t\tindirectBuffer[indirectIndex]
      = index;\n#endif\n#endif\n\t}\n}\n"
  - compute: 0
    name: '[System 2]Shader Graph Quad Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 2/Shader Graph Quad Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Transparent+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      // #define _HAS_REFRACTION 1\n                        // #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n                float Vector1_230F773D = particleId;\n           
      \n\n    if( !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    float4
      _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      float _Property_9E2640C5_Out_0 = Vector1_230F773D;\n                                   
      float _Multiply_CC71DB85_Out_2;\n                                    Unity_Multiply_float(_Property_9E2640C5_Out_0,
      0.6, _Multiply_CC71DB85_Out_2);\n                                    float
      _Add_26D7501B_Out_2;\n                                    Unity_Add_float(_Multiply_CC71DB85_Out_2,
      0.1, _Add_26D7501B_Out_2);\n                                    surface.Albedo
      = IsGammaSpace() ? float3(0.7353569, 0.7353569, 0.7353569) : SRGBToLinear(float3(0.7353569,
      0.7353569, 0.7353569));\n                                    surface.Normal
      = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 0;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = _Add_26D7501B_Out_2;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      // #define _HAS_REFRACTION 1\n                        // #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n                float Vector1_230F773D = particleId;\n           
      \n\n    if( !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    float
      _Property_9E2640C5_Out_0 = Vector1_230F773D;\n                                   
      float _Multiply_CC71DB85_Out_2;\n                                    Unity_Multiply_float(_Property_9E2640C5_Out_0,
      0.6, _Multiply_CC71DB85_Out_2);\n                                    float
      _Add_26D7501B_Out_2;\n                                    Unity_Add_float(_Multiply_CC71DB85_Out_2,
      0.1, _Add_26D7501B_Out_2);\n                                    surface.Alpha
      = _Add_26D7501B_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      // #define _HAS_REFRACTION 1\n                        // #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n                float Vector1_230F773D = particleId;\n           
      \n\n    if( !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    float
      _Property_9E2640C5_Out_0 = Vector1_230F773D;\n                                   
      float _Multiply_CC71DB85_Out_2;\n                                    Unity_Multiply_float(_Property_9E2640C5_Out_0,
      0.6, _Multiply_CC71DB85_Out_2);\n                                    float
      _Add_26D7501B_Out_2;\n                                    Unity_Add_float(_Multiply_CC71DB85_Out_2,
      0.1, _Add_26D7501B_Out_2);\n                                    surface.Alpha
      = _Add_26D7501B_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthOnly\"\n           
      Tags {\"LightMode\" = \"DepthOnly\" }\n            Cull Back\n            ZWrite
      On\n            Stencil\n            {\n                WriteMask 48\n               
      Ref 0\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      // #define _HAS_REFRACTION 1\n                        // #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   AlphaFog\n                           
      //   BlendMode.PreserveSpecular\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n                float Vector1_230F773D = particleId;\n           
      \n\n    if( !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    float4
      _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      float _Property_9E2640C5_Out_0 = Vector1_230F773D;\n                                   
      float _Multiply_CC71DB85_Out_2;\n                                    Unity_Multiply_float(_Property_9E2640C5_Out_0,
      0.6, _Multiply_CC71DB85_Out_2);\n                                    float
      _Add_26D7501B_Out_2;\n                                    Unity_Add_float(_Multiply_CC71DB85_Out_2,
      0.1, _Add_26D7501B_Out_2);\n                                    surface.Normal
      = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = _Add_26D7501B_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"GBuffer\"\n           
      Tags {\"LightMode\" = \"GBuffer\" }\n            Cull Back\n            ZTest
      LEqual\n            Stencil\n            {\n                WriteMask 51\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      // #define _HAS_REFRACTION 1\n                        // #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_GBUFFER\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      _ LIGHT_LAYERS\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   AlphaFog\n                           
      //   BlendMode.PreserveSpecular\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n                float Vector1_230F773D = particleId;\n           
      \n\n    if( !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    float4
      _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      float _Property_9E2640C5_Out_0 = Vector1_230F773D;\n                                   
      float _Multiply_CC71DB85_Out_2;\n                                    Unity_Multiply_float(_Property_9E2640C5_Out_0,
      0.6, _Multiply_CC71DB85_Out_2);\n                                    float
      _Add_26D7501B_Out_2;\n                                    Unity_Add_float(_Multiply_CC71DB85_Out_2,
      0.1, _Add_26D7501B_Out_2);\n                                    surface.Albedo
      = IsGammaSpace() ? float3(0.7353569, 0.7353569, 0.7353569) : SRGBToLinear(float3(0.7353569,
      0.7353569, 0.7353569));\n                                    surface.Normal
      = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 0;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = _Add_26D7501B_Out_2;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassGBuffer.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            Stencil\n            {\n                WriteMask 176\n               
      Ref 128\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      // #define _HAS_REFRACTION 1\n                        // #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   AlphaFog\n                           
      //   BlendMode.PreserveSpecular\n                            //   Specular.EnergyConserving\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n                float Vector1_230F773D = particleId;\n           
      \n\n    if( !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    float4
      _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      float _Property_9E2640C5_Out_0 = Vector1_230F773D;\n                                   
      float _Multiply_CC71DB85_Out_2;\n                                    Unity_Multiply_float(_Property_9E2640C5_Out_0,
      0.6, _Multiply_CC71DB85_Out_2);\n                                    float
      _Add_26D7501B_Out_2;\n                                    Unity_Add_float(_Multiply_CC71DB85_Out_2,
      0.1, _Add_26D7501B_Out_2);\n                                    surface.Normal
      = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = _Add_26D7501B_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"Forward\"\n           
      Tags {\"LightMode\" = \"Forward\" }\n            Cull Back\n            ZTest
      LEqual\n            ZWrite Off\n            ColorMask RGBA 1\n            Blend
      One OneMinusSrcAlpha, One OneMinusSrcAlpha\n            Stencil\n           
      {\n                WriteMask 3\n                Ref 2\n                Comp
      Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                    #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _DOUBLESIDED_ON\n                        #pragma shader_feature_local _ _BLENDMODE_ALPHA
      _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      // #define _HAS_REFRACTION 1\n                        // #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #define USE_CLUSTERED_LIGHTLIST\n                           
      #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.CoatMask\n                            //   SurfaceDescription.Metallic\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_1AFC26DB_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_1AFC26DB_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float CoatMask;\n                                   
      float Metallic;\n                                    float3 Emission;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n                float Vector1_230F773D = particleId;\n           
      \n\n    if( !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    float4
      _SampleTexture2D_1AFC26DB_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_1AFC26DB_Texture_1,
      sampler_SampleTexture2D_1AFC26DB_Texture_1, IN.uv0.xy);\n                                   
      _SampleTexture2D_1AFC26DB_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_1AFC26DB_RGBA_0);\n                                   
      float _SampleTexture2D_1AFC26DB_R_4 = _SampleTexture2D_1AFC26DB_RGBA_0.r;\n                                   
      float _SampleTexture2D_1AFC26DB_G_5 = _SampleTexture2D_1AFC26DB_RGBA_0.g;\n                                   
      float _SampleTexture2D_1AFC26DB_B_6 = _SampleTexture2D_1AFC26DB_RGBA_0.b;\n                                   
      float _SampleTexture2D_1AFC26DB_A_7 = _SampleTexture2D_1AFC26DB_RGBA_0.a;\n                                   
      float _Property_9E2640C5_Out_0 = Vector1_230F773D;\n                                   
      float _Multiply_CC71DB85_Out_2;\n                                    Unity_Multiply_float(_Property_9E2640C5_Out_0,
      0.6, _Multiply_CC71DB85_Out_2);\n                                    float
      _Add_26D7501B_Out_2;\n                                    Unity_Add_float(_Multiply_CC71DB85_Out_2,
      0.1, _Add_26D7501B_Out_2);\n                                    surface.Albedo
      = IsGammaSpace() ? float3(0.7353569, 0.7353569, 0.7353569) : SRGBToLinear(float3(0.7353569,
      0.7353569, 0.7353569));\n                                    surface.Normal
      = (_SampleTexture2D_1AFC26DB_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.CoatMask = 0;\n                                    surface.Metallic
      = 0;\n                                    surface.Emission = float3(0, 0, 0);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = _Add_26D7501B_Out_2;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      \n            PackedVaryingsType ParticleVert(uint id : SV_VertexID,uint instID
      : SV_InstanceID)\n            {\n             uint particleID = (id >> 2) +
      instID * 2048;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n                float2 uv;\n               
      uv.x = float(id & 1);\n             uv.y = float((id & 2) >> 1);\n           
      #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy = uv;\n           
      #endif\n                inputMesh.positionOS = float3(uv - 0.5f,0);\n               
      inputMesh.particleID = particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             \n               
      float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 2]Shader Graph Quad Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 2/Shader Graph Quad Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Transparent+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.Silk\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceTangent\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Occlusion\n                            //   SurfaceDescription.Specular\n                           
      //   SurfaceDescription.Tangent\n                            //   SurfaceDescription.Anisotropy\n                           
      //   SurfaceDescription.Emission\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float3
      TangentSpaceTangent; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float3 Specular;\n                                    float3 Tangent;\n                                   
      float Anisotropy;\n                                    float3 Emission;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_21A3DC61_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_21A3DC61_Texture_1,
      sampler_SampleTexture2D_21A3DC61_Texture_1, IN.uv0.xy);\n                                   
      float _SampleTexture2D_21A3DC61_R_4 = _SampleTexture2D_21A3DC61_RGBA_0.r;\n                                   
      float _SampleTexture2D_21A3DC61_G_5 = _SampleTexture2D_21A3DC61_RGBA_0.g;\n                                   
      float _SampleTexture2D_21A3DC61_B_6 = _SampleTexture2D_21A3DC61_RGBA_0.b;\n                                   
      float _SampleTexture2D_21A3DC61_A_7 = _SampleTexture2D_21A3DC61_RGBA_0.a;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      float _Vector1_FFF32966_Out_0 = 1;\n                                    float
      _Multiply_8C8CFD2C_Out_2;\n                                    Unity_Multiply_float(_Vector1_FFF32966_Out_0,
      0.6, _Multiply_8C8CFD2C_Out_2);\n                                    float
      _Add_31E602F8_Out_2;\n                                    Unity_Add_float(_Multiply_8C8CFD2C_Out_2,
      0.1, _Add_31E602F8_Out_2);\n                                    surface.Albedo
      = (_SampleTexture2D_21A3DC61_RGBA_0.xyz);\n                                   
      surface.Normal = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Specular = IsGammaSpace()
      ? float3(0.2, 0.2, 0.2) : SRGBToLinear(float3(0.2, 0.2, 0.2));\n                                   
      surface.Tangent = IN.TangentSpaceTangent;\n                                   
      surface.Anisotropy = 0.8;\n                                    surface.Emission
      = float3(0, 0, 0);\n                                    surface.Alpha = _Add_31E602F8_Out_2;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.46,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.Silk\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceTangent\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float3
      TangentSpaceTangent; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Vector1_FFF32966_Out_0 = 1;\n                                    float
      _Multiply_8C8CFD2C_Out_2;\n                                    Unity_Multiply_float(_Vector1_FFF32966_Out_0,
      0.6, _Multiply_8C8CFD2C_Out_2);\n                                    float
      _Add_31E602F8_Out_2;\n                                    Unity_Add_float(_Multiply_8C8CFD2C_Out_2,
      0.1, _Add_31E602F8_Out_2);\n                                    surface.Alpha
      = _Add_31E602F8_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      // surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.46,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      Blend One Zero\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.Silk\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceTangent\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float3
      TangentSpaceTangent; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Vector1_FFF32966_Out_0 = 1;\n                                    float
      _Multiply_8C8CFD2C_Out_2;\n                                    Unity_Multiply_float(_Vector1_FFF32966_Out_0,
      0.6, _Multiply_8C8CFD2C_Out_2);\n                                    float
      _Add_31E602F8_Out_2;\n                                    Unity_Add_float(_Multiply_8C8CFD2C_Out_2,
      0.1, _Add_31E602F8_Out_2);\n                                    surface.Alpha
      = _Add_31E602F8_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      // surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.46,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            Cull Back\n           
      ZWrite On\n            Stencil\n            {\n                WriteMask 48\n               
      Ref 0\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.Silk\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceTangent\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float3
      TangentSpaceTangent; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      float _Vector1_FFF32966_Out_0 = 1;\n                                    float
      _Multiply_8C8CFD2C_Out_2;\n                                    Unity_Multiply_float(_Vector1_FFF32966_Out_0,
      0.6, _Multiply_8C8CFD2C_Out_2);\n                                    float
      _Add_31E602F8_Out_2;\n                                    Unity_Add_float(_Multiply_8C8CFD2C_Out_2,
      0.1, _Add_31E602F8_Out_2);\n                                    surface.Normal
      = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = _Add_31E602F8_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.46,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      Stencil\n            {\n                WriteMask 176\n                Ref
      128\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.Silk\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceTangent\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float3
      TangentSpaceTangent; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Multiply_float (float A, float
      B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      float _Vector1_FFF32966_Out_0 = 1;\n                                    float
      _Multiply_8C8CFD2C_Out_2;\n                                    Unity_Multiply_float(_Vector1_FFF32966_Out_0,
      0.6, _Multiply_8C8CFD2C_Out_2);\n                                    float
      _Add_31E602F8_Out_2;\n                                    Unity_Add_float(_Multiply_8C8CFD2C_Out_2,
      0.1, _Add_31E602F8_Out_2);\n                                    surface.Normal
      = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = _Add_31E602F8_Out_2;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.46,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ForwardOnly\"\n           
      Tags {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n           
      ZTest LEqual\n            ZWrite Off\n            Blend One OneMinusSrcAlpha,
      One OneMinusSrcAlpha\n            Stencil\n            {\n                WriteMask
      3\n                Ref 2\n                Comp Always\n                Pass
      Replace\n            }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_COTTON_WOOL 1\n                        // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING
      1\n                        #define _ENABLE_FOG_ON_TRANSPARENT 1\n                       
      // #define _OCCLUSION 1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL
      1\n                        // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                       
      #define _ENERGY_CONSERVING_SPECULAR 1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA
      1\n                        // #define _DISABLE_DECALS 1\n                       
      // #define _DISABLE_SSR 1\n                        // #define _DEPTHOFFSET_ON
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #define USE_CLUSTERED_LIGHTLIST\n                           
      #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.Silk\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceTangent\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Specular\n                            //   SurfaceDescription.Tangent\n                           
      //   SurfaceDescription.Anisotropy\n                            //   SurfaceDescription.Emission\n                           
      //   SurfaceDescription.Alpha\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   AttributesMesh.uv3\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord0\n                            //   FragInputs.texCoord1\n                           
      //   FragInputs.texCoord2\n                            //   FragInputs.texCoord3\n                           
      //   FragInputs.color\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   VaryingsMeshToPS.texCoord1\n                           
      //   VaryingsMeshToPS.texCoord2\n                            //   VaryingsMeshToPS.texCoord3\n                           
      //   VaryingsMeshToPS.color\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define VARYINGS_NEED_TEXCOORD0\n                       
      #define VARYINGS_NEED_TEXCOORD1\n                        #define VARYINGS_NEED_TEXCOORD2\n                       
      #define VARYINGS_NEED_TEXCOORD3\n                        #define VARYINGS_NEED_COLOR\n                       
      // #define VARYINGS_NEED_CULLFACE\n                        // #define HAVE_MESH_MODIFICATION\n                   
      \n                    // We need isFontFace when using double sided\n                   
      #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n                       
      #define VARYINGS_NEED_CULLFACE\n                    #endif\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Fabric/Fabric.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            Texture2D _SampleTexture2D_21A3DC61_Texture_1;\n           
      SamplerState sampler_SampleTexture2D_21A3DC61_Texture_1;\n            Texture2D
      _SampleTexture2D_8E752C4E_Texture_1;\n            SamplerState sampler_SampleTexture2D_8E752C4E_Texture_1;\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float3
      TangentSpaceTangent; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float Smoothness;\n                                   
      float Occlusion;\n                                    float3 Specular;\n                                   
      float3 Tangent;\n                                    float Anisotropy;\n                                   
      float3 Emission;\n                                    float Alpha;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n                                void Unity_Multiply_float
      (float A, float B, out float Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                                void Unity_Add_float(float A, float B, out
      float Out)\n                                {\n                                   
      Out = A + B;\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _SampleTexture2D_21A3DC61_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_21A3DC61_Texture_1,
      sampler_SampleTexture2D_21A3DC61_Texture_1, IN.uv0.xy);\n                                   
      float _SampleTexture2D_21A3DC61_R_4 = _SampleTexture2D_21A3DC61_RGBA_0.r;\n                                   
      float _SampleTexture2D_21A3DC61_G_5 = _SampleTexture2D_21A3DC61_RGBA_0.g;\n                                   
      float _SampleTexture2D_21A3DC61_B_6 = _SampleTexture2D_21A3DC61_RGBA_0.b;\n                                   
      float _SampleTexture2D_21A3DC61_A_7 = _SampleTexture2D_21A3DC61_RGBA_0.a;\n                                   
      float4 _UV_A32239A0_Out_0 = IN.uv0;\n                                    float4
      _Multiply_AC5239EF_Out_2;\n                                    Unity_Multiply_float(_UV_A32239A0_Out_0,
      float4(2, 1, 1, 1), _Multiply_AC5239EF_Out_2);\n                                   
      float4 _SampleTexture2D_8E752C4E_RGBA_0 = SAMPLE_TEXTURE2D(_SampleTexture2D_8E752C4E_Texture_1,
      sampler_SampleTexture2D_8E752C4E_Texture_1, (_Multiply_AC5239EF_Out_2.xy));\n                                   
      float _SampleTexture2D_8E752C4E_R_4 = _SampleTexture2D_8E752C4E_RGBA_0.r;\n                                   
      float _SampleTexture2D_8E752C4E_G_5 = _SampleTexture2D_8E752C4E_RGBA_0.g;\n                                   
      float _SampleTexture2D_8E752C4E_B_6 = _SampleTexture2D_8E752C4E_RGBA_0.b;\n                                   
      float _SampleTexture2D_8E752C4E_A_7 = _SampleTexture2D_8E752C4E_RGBA_0.a;\n                                   
      float _Vector1_FFF32966_Out_0 = 1;\n                                    float
      _Multiply_8C8CFD2C_Out_2;\n                                    Unity_Multiply_float(_Vector1_FFF32966_Out_0,
      0.6, _Multiply_8C8CFD2C_Out_2);\n                                    float
      _Add_31E602F8_Out_2;\n                                    Unity_Add_float(_Multiply_8C8CFD2C_Out_2,
      0.1, _Add_31E602F8_Out_2);\n                                    surface.Albedo
      = (_SampleTexture2D_21A3DC61_RGBA_0.xyz);\n                                   
      surface.Normal = (_SampleTexture2D_8E752C4E_RGBA_0.xyz);\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Specular = IsGammaSpace()
      ? float3(0.2, 0.2, 0.2) : SRGBToLinear(float3(0.2, 0.2, 0.2));\n                                   
      surface.Tangent = IN.TangentSpaceTangent;\n                                   
      surface.Anisotropy = 0.8;\n                                    surface.Emission
      = float3(0, 0, 0);\n                                    surface.Alpha = _Add_31E602F8_Out_2;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.baseColor.xyz = surfaceData.baseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature (note that silk flag is deduced from the abscence
      of this one)\n                    #ifdef _MATERIAL_FEATURE_COTTON_WOOL\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_COTTON_WOOL;\n                           
      surfaceData.perceptualSmoothness =      lerp(0.0, 0.6, surfaceDescription.Smoothness);\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_FABRIC_TRANSMISSION;\n                   
      #endif\n                    \n                    \n                    #if
      defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      DEBUG_DISPLAY\n                            if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                            \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,2.46,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz
      = normalize(transpose(elementToVFX)[0].xyz);\n                #endif\n           
      \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 2]Shader Graph Mesh Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 2/Shader Graph Mesh Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Transparent+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      #define _HAS_REFRACTION 1\n                        #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   Refraction\n                           
      //   RefractionBox\n                            //   CoatMask\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.Thickness\n                            //   SurfaceDescription.CoatMask\n                           
      //   SurfaceDescription.Metallic\n                            //   SurfaceDescription.Emission\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.RefractionIndex\n                           
      //   SurfaceDescription.RefractionColor\n                            //   SurfaceDescription.RefractionDistance\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float Thickness;\n                                   
      float CoatMask;\n                                    float Metallic;\n                                   
      float3 Emission;\n                                    float Smoothness;\n                                   
      float Occlusion;\n                                    float Alpha;\n                                   
      float RefractionIndex;\n                                    float3 RefractionColor;\n                                   
      float RefractionDistance;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Voronoi_2A1D40B5_Out_3;\n                                    float _Voronoi_2A1D40B5_Cells_4;\n                                   
      Unity_Voronoi_float(IN.uv0.xy, 2, 17.66, _Voronoi_2A1D40B5_Out_3, _Voronoi_2A1D40B5_Cells_4);\n                                   
      surface.Albedo = (_Voronoi_2A1D40B5_Cells_4.xxx);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.Thickness = 1;\n                                    surface.CoatMask
      = 1;\n                                    surface.Metallic = 0;\n                                   
      surface.Emission = float3(0, 0, 0);\n                                    surface.Smoothness
      = 0.5;\n                                    surface.Occlusion = 1;\n                                   
      surface.Alpha = 0.1;\n                                    surface.RefractionIndex
      = 1;\n                                    surface.RefractionColor = IsGammaSpace()
      ? float3(1, 1, 1) : SRGBToLinear(float3(1, 1, 1));\n                                   
      surface.RefractionDistance = 1;\n                                    surface.Alpha
      *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.26,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      #define _HAS_REFRACTION 1\n                        #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   Refraction\n                           
      //   RefractionBox\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 0.1;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.26,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      #define _HAS_REFRACTION 1\n                        #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   Refraction\n                           
      //   RefractionBox\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 0.1;\n                                    surface.Alpha *=
      alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            //
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                           
      // surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            // normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.26,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthOnly\"\n           
      Tags {\"LightMode\" = \"DepthOnly\" }\n            Cull Back\n            ZWrite
      On\n            Stencil\n            {\n                WriteMask 48\n               
      Ref 0\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      #define _HAS_REFRACTION 1\n                        #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   AlphaFog\n                           
      //   BlendMode.PreserveSpecular\n                            //   Specular.EnergyConserving\n                           
      //   Refraction\n                            //   RefractionBox\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Alpha\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   AttributesMesh.uv3\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord0\n                            //   FragInputs.texCoord1\n                           
      //   FragInputs.texCoord2\n                            //   FragInputs.texCoord3\n                           
      //   FragInputs.color\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   VaryingsMeshToPS.texCoord1\n                           
      //   VaryingsMeshToPS.texCoord2\n                            //   VaryingsMeshToPS.texCoord3\n                           
      //   VaryingsMeshToPS.color\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define VARYINGS_NEED_TEXCOORD0\n                       
      #define VARYINGS_NEED_TEXCOORD1\n                        #define VARYINGS_NEED_TEXCOORD2\n                       
      #define VARYINGS_NEED_TEXCOORD3\n                        #define VARYINGS_NEED_COLOR\n                       
      // #define VARYINGS_NEED_CULLFACE\n                        // #define HAVE_MESH_MODIFICATION\n                   
      \n                    // We need isFontFace when using double sided\n                   
      #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n                       
      #define VARYINGS_NEED_CULLFACE\n                    #endif\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 0.1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.26,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"GBuffer\"\n           
      Tags {\"LightMode\" = \"GBuffer\" }\n            Cull Back\n            ZTest
      LEqual\n            Stencil\n            {\n                WriteMask 51\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      #define _HAS_REFRACTION 1\n                        #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_GBUFFER\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      _ LIGHT_LAYERS\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   AlphaFog\n                           
      //   BlendMode.PreserveSpecular\n                            //   Specular.EnergyConserving\n                           
      //   Refraction\n                            //   RefractionBox\n                           
      //   CoatMask\n                            //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.Thickness\n                            //   SurfaceDescription.CoatMask\n                           
      //   SurfaceDescription.Metallic\n                            //   SurfaceDescription.Emission\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.RefractionIndex\n                           
      //   SurfaceDescription.RefractionColor\n                            //   SurfaceDescription.RefractionDistance\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float Thickness;\n                                   
      float CoatMask;\n                                    float Metallic;\n                                   
      float3 Emission;\n                                    float Smoothness;\n                                   
      float Occlusion;\n                                    float Alpha;\n                                   
      float RefractionIndex;\n                                    float3 RefractionColor;\n                                   
      float RefractionDistance;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Voronoi_2A1D40B5_Out_3;\n                                    float _Voronoi_2A1D40B5_Cells_4;\n                                   
      Unity_Voronoi_float(IN.uv0.xy, 2, 17.66, _Voronoi_2A1D40B5_Out_3, _Voronoi_2A1D40B5_Cells_4);\n                                   
      surface.Albedo = (_Voronoi_2A1D40B5_Cells_4.xxx);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.Thickness = 1;\n                                    surface.CoatMask
      = 1;\n                                    surface.Metallic = 0;\n                                   
      surface.Emission = float3(0, 0, 0);\n                                    surface.Smoothness
      = 0.5;\n                                    surface.Occlusion = 1;\n                                   
      surface.Alpha = 0.1;\n                                    surface.RefractionIndex
      = 1;\n                                    surface.RefractionColor = IsGammaSpace()
      ? float3(1, 1, 1) : SRGBToLinear(float3(1, 1, 1));\n                                   
      surface.RefractionDistance = 1;\n                                    surface.Alpha
      *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassGBuffer.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.26,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            Stencil\n            {\n                WriteMask 176\n               
      Ref 128\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                   
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma
      shader_feature_local _DOUBLESIDED_ON\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      #define _HAS_REFRACTION 1\n                        #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_NORMAL_BUFFER\n                            #pragma multi_compile
      _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   Material.Standard\n                            //   AlphaFog\n                           
      //   BlendMode.PreserveSpecular\n                            //   Specular.EnergyConserving\n                           
      //   Refraction\n                            //   RefractionBox\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.Smoothness\n                           
      //   SurfaceDescription.Alpha\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   AttributesMesh.uv3\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord0\n                            //   FragInputs.texCoord1\n                           
      //   FragInputs.texCoord2\n                            //   FragInputs.texCoord3\n                           
      //   FragInputs.color\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   VaryingsMeshToPS.texCoord1\n                           
      //   VaryingsMeshToPS.texCoord2\n                            //   VaryingsMeshToPS.texCoord3\n                           
      //   VaryingsMeshToPS.color\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define VARYINGS_NEED_TEXCOORD0\n                       
      #define VARYINGS_NEED_TEXCOORD1\n                        #define VARYINGS_NEED_TEXCOORD2\n                       
      #define VARYINGS_NEED_TEXCOORD3\n                        #define VARYINGS_NEED_COLOR\n                       
      // #define VARYINGS_NEED_CULLFACE\n                        // #define HAVE_MESH_MODIFICATION\n                   
      \n                    // We need isFontFace when using double sided\n                   
      #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n                       
      #define VARYINGS_NEED_CULLFACE\n                    #endif\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Alpha
      = 0.1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            // surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            // surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      // surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      // surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.26,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"Forward\"\n           
      Tags {\"LightMode\" = \"Forward\" }\n            Cull Back\n            ZTest
      LEqual\n            ZWrite Off\n            ColorMask RGBA 1\n            Blend
      One OneMinusSrcAlpha, One OneMinusSrcAlpha\n            Stencil\n           
      {\n                WriteMask 3\n                Ref 2\n                Comp
      Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                    #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _DOUBLESIDED_ON\n                        #pragma shader_feature_local _ _BLENDMODE_ALPHA
      _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n                       
      // #define _MATERIAL_FEATURE_TRANSMISSION 1\n                        // #define
      _MATERIAL_FEATURE_ANISOTROPY 1\n                        // #define _MATERIAL_FEATURE_IRIDESCENCE
      1\n                        // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n                       
      #define _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _AMBIENT_OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        #define _ENERGY_CONSERVING_SPECULAR
      1\n                        // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                       
      #define _HAS_REFRACTION 1\n                        #define _REFRACTION_PLANE
      1\n                        // #define _REFRACTION_SPHERE 1\n                       
      // #define _DISABLE_DECALS 1\n                        // #define _DISABLE_SSR
      1\n                        // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                       
      // #define _DEPTHOFFSET_ON 1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n                        #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n                        #define OUTPUT_SPLIT_LIGHTING\n                       
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #define USE_CLUSTERED_LIGHTLIST\n                           
      #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.Standard\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   Specular.EnergyConserving\n                            //   Refraction\n                           
      //   RefractionBox\n                            //   CoatMask\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.Thickness\n                            //   SurfaceDescription.CoatMask\n                           
      //   SurfaceDescription.Metallic\n                            //   SurfaceDescription.Emission\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.RefractionIndex\n                           
      //   SurfaceDescription.RefractionColor\n                            //   SurfaceDescription.RefractionDistance\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.positionOS\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float Thickness;\n                                   
      float CoatMask;\n                                    float Metallic;\n                                   
      float3 Emission;\n                                    float Smoothness;\n                                   
      float Occlusion;\n                                    float Alpha;\n                                   
      float RefractionIndex;\n                                    float3 RefractionColor;\n                                   
      float RefractionDistance;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float _Voronoi_2A1D40B5_Out_3;\n                                    float _Voronoi_2A1D40B5_Cells_4;\n                                   
      Unity_Voronoi_float(IN.uv0.xy, 2, 17.66, _Voronoi_2A1D40B5_Out_3, _Voronoi_2A1D40B5_Cells_4);\n                                   
      surface.Albedo = (_Voronoi_2A1D40B5_Cells_4.xxx);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.Thickness = 1;\n                                    surface.CoatMask
      = 1;\n                                    surface.Metallic = 0;\n                                   
      surface.Emission = float3(0, 0, 0);\n                                    surface.Smoothness
      = 0.5;\n                                    surface.Occlusion = 1;\n                                   
      surface.Alpha = 0.1;\n                                    surface.RefractionIndex
      = 1;\n                                    surface.RefractionColor = IsGammaSpace()
      ? float3(1, 1, 1) : SRGBToLinear(float3(1, 1, 1));\n                                   
      surface.RefractionDistance = 1;\n                                    surface.Alpha
      *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n                       
      {\n                            // setup defaults -- these are used if the graph
      doesn't output a value\n                            ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n                    \n                            // copy across
      graph values, if defined\n                            surfaceData.baseColor
      =                 surfaceDescription.Albedo;\n                            surfaceData.perceptualSmoothness
      =      surfaceDescription.Smoothness;\n                            surfaceData.ambientOcclusion
      =          surfaceDescription.Occlusion;\n                            // surfaceData.specularOcclusion
      =         surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                           
      // surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                           
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                           
      // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                           
      // surfaceData.specularColor =             surfaceDescription.Specular;\n                           
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                           
      // surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                           
      // surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                           
      // surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n                   
      \n                    #ifdef _HAS_REFRACTION\n                            if
      (_EnableSSRefraction)\n                            {\n                               
      surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                               
      surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                               
      surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n                   
      \n                                surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                               
      surfaceDescription.Alpha = 1.0;\n                            }\n                           
      else\n                            {\n                                surfaceData.ior
      = 1.0;\n                                surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                                surfaceData.atDistance = 1.0;\n                               
      surfaceData.transmittanceMask = 0.0;\n                                surfaceDescription.Alpha
      = 1.0;\n                            }\n                    #else\n                           
      surfaceData.ior = 1.0;\n                            surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                            surfaceData.atDistance
      = 1.0;\n                            surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n                            \n                            // These
      static material feature allow compile time optimization\n                           
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                   
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                            surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                    \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                            // Require
      to have setup baseColor\n                            // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                            surfaceData.baseColor *= (1.0
      - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // tangent-space normal\n                            float3 normalTS = float3(0.0f,
      0.0f, 1.0f);\n                            normalTS = surfaceDescription.Normal;\n                   
      \n                            // compute world space normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                            bentNormalWS = surfaceData.normalWS;\n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);   
      // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if
      it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                           
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n                            surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                               
      surfaceData.metallic = 0;\n                            }\n                   
      \n                            // We need to call ApplyDebugToSurfaceData after
      filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                           
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                    \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #else\n                            builtinData.distortion = float2(0.0, 0.0);\n                           
      builtinData.distortionBlur = 0.0;\n                    #endif\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x4) << 2));\n                float size = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x7) << 2));\n                float angleX = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x14) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (bool)true;\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,5.26,0));\n            
      }\n             \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 1
    name: '[System 2]Initialize'
    source: "#pragma kernel CSMain\n#define NB_THREADS_PER_GROUP 64\n#define VFX_USE_PARTICLEID_CURRENT
      1\n#define VFX_USE_POSITION_CURRENT 1\n#define VFX_USE_SIZE_CURRENT 1\n#define
      VFX_USE_ANGLEX_CURRENT 1\n#define VFX_LOCAL_SPACE 1\n#include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n\n\n\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/Common/VFXCommonCompute.cginc\"\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n\n\n\nRWByteAddressBuffer
      attributeBuffer;\nByteAddressBuffer sourceAttributeBuffer;\n\nCBUFFER_START(initParams)\n#if
      !VFX_USE_SPAWNER_FROM_GPU\n    uint nbSpawned;\t\t\t\t\t// Numbers of particle
      spawned\n    uint spawnIndex;\t\t\t\t// Index of the first particle spawned\n   
      uint dispatchWidth;\n#else\n    uint offsetInAdditionalOutput;\n\tuint nbMax;\n#endif\n\tuint
      systemSeed;\nCBUFFER_END\n\n#if VFX_USE_ALIVE_CURRENT\nRWStructuredBuffer<uint>
      deadListIn;\nByteAddressBuffer deadListCount; // This is bad to use a SRV to
      fetch deadList count but Unity API currently prevent from copying to CB\n#endif\n\n#if
      VFX_USE_SPAWNER_FROM_GPU\nStructuredBuffer<uint> eventList;\nByteAddressBuffer
      inputAdditional;\n#endif\n\nvoid PositionSequential_267A9(uint particleId,
      inout float3 position, float3 computedPosition) /*shape:Line index:ParticleID
      writePosition:True writeTargetPosition:False mode:Wrap */\n{\n    position
      += computedPosition;\n    \n}\nvoid SetAttribute_3278B22F(inout float size,
      float Size) /*attribute:size Composition:Overwrite Source:Slot Random:Off channels:XYZ
      */\n{\n    size = Size;\n}\nvoid SetAttribute_C707D62A(inout float3 position,
      float3 Position) /*attribute:position Composition:Add Source:Slot Random:Off
      channels:XYZ */\n{\n    position += Position;\n}\n\n\n\n[numthreads(NB_THREADS_PER_GROUP,1,1)]\nvoid
      CSMain(uint3 groupId          : SV_GroupID,\n            uint3 groupThreadId   
      : SV_GroupThreadID)\n{\n    uint id = groupThreadId.x + groupId.x * NB_THREADS_PER_GROUP;\n#if
      !VFX_USE_SPAWNER_FROM_GPU\n    id += groupId.y * dispatchWidth * NB_THREADS_PER_GROUP;\n#endif\n\n#if
      VFX_USE_SPAWNER_FROM_GPU\n    uint maxThreadId = inputAdditional.Load((offsetInAdditionalOutput
      * 2 + 0) << 2);\n    uint currentSpawnIndex = inputAdditional.Load((offsetInAdditionalOutput
      * 2 + 1) << 2) - maxThreadId;\n#else\n    uint maxThreadId = nbSpawned;\n   
      uint currentSpawnIndex = spawnIndex;\n#endif\n\n#if VFX_USE_ALIVE_CURRENT\n   
      maxThreadId = min(maxThreadId, deadListCount.Load(0x0));\n#elif VFX_USE_SPAWNER_FROM_GPU\n   
      maxThreadId = min(maxThreadId, nbMax); //otherwise, nbSpawned already clamped
      on CPU\n#endif\n\n    if (id < maxThreadId)\n    {\n#if VFX_USE_SPAWNER_FROM_GPU\n       
      int sourceIndex = eventList[id];\n#endif\n        uint particleIndex = id +
      currentSpawnIndex;\n\t\t\n#if !VFX_USE_SPAWNER_FROM_GPU\n        int sourceIndex
      = 0;\n        /*//Loop with 1 iteration generate a wrong IL Assembly (and actually,
      useless code)\n        uint currentSumSpawnCount = 0u;\n        for (sourceIndex=0;
      sourceIndex<1; sourceIndex++)\n        {\n            currentSumSpawnCount
      += uint(asfloat(sourceAttributeBuffer.Load((sourceIndex * 0x1 + 0x0) << 2)));\n           
      if (id < currentSumSpawnCount)\n            {\n                break;\n           
      }\n        }\n        */\n        \n\n#endif\n        uint particleId = (uint)0;\n       
      float3 position = float3(0,0,0);\n        float size = (float)0.1;\n       
      float angleX = (float)0;\n        \n\n#if VFX_USE_PARTICLEID_CURRENT\n        
      particleId = particleIndex;\n#endif\n#if VFX_USE_SEED_CURRENT\n        seed
      = WangHash(particleIndex ^ systemSeed);\n#endif\n        \n        {\n           
      uint tmp_t = particleId / (uint)2;\n            uint tmp_u = tmp_t * (uint)2;\n           
      uint tmp_v = particleId - tmp_u;\n            float tmp_w = (float)tmp_v;\n           
      float3 tmp_x = float3(tmp_w, tmp_w, tmp_w);\n            float3 tmp_z = tmp_x
      * float3(2,0,0);\n            PositionSequential_267A9(particleId,  /*inout
      */position, tmp_z);\n        }\n        {\n            SetAttribute_3278B22F(
      /*inout */size, (float)1.67);\n        }\n        {\n            SetAttribute_C707D62A(
      /*inout */position, float3(5,0,0));\n        }\n        \n\n\n#if VFX_USE_ALIVE_CURRENT\n       
      if (alive)\n        {\n\t\t\tuint deadIndex = deadListIn.DecrementCounter();\n           
      uint index = deadListIn[deadIndex];\n            attributeBuffer.Store((index
      * 0x1 + 0x0) << 2,asuint(particleId));\n            attributeBuffer.Store3((index
      * 0x4 + 0x4) << 2,asuint(position));\n            attributeBuffer.Store((index
      * 0x4 + 0x7) << 2,asuint(size));\n            attributeBuffer.Store((index
      * 0x1 + 0x14) << 2,asuint(angleX));\n            \n\n        }\n#else\n       
      uint index = particleIndex;\n        attributeBuffer.Store((index * 0x1 + 0x0)
      << 2,asuint(particleId));\n        attributeBuffer.Store3((index * 0x4 + 0x4)
      << 2,asuint(position));\n        attributeBuffer.Store((index * 0x4 + 0x7)
      << 2,asuint(size));\n        attributeBuffer.Store((index * 0x1 + 0x14) <<
      2,asuint(angleX));\n        \n\n#endif\n    }\n}\n"
  - compute: 0
    name: '[System 1]Shader Graph Mesh Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 1/Shader Graph Mesh Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        // #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   SurfaceDescriptionInputs.WorldSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.WorldSpaceTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpaceBiTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpacePosition\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.HairStrandDirection\n                            //  
      SurfaceDescription.Transmittance\n                            //   SurfaceDescription.RimTransmissionIntensity\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.SpecularTint\n                           
      //   SurfaceDescription.SpecularShift\n                            //   SurfaceDescription.SecondarySpecularTint\n                           
      //   SurfaceDescription.SecondarySmoothness\n                            //  
      SurfaceDescription.SecondarySpecularShift\n                            //  
      AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.tangentToWorld\n                            //   FragInputs.positionRWS\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.tangentWS\n                           
      //   VaryingsMeshToPS.normalWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   VaryingsMeshToPS.texCoord0\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define VARYINGS_NEED_TEXCOORD0\n                       
      // #define VARYINGS_NEED_TEXCOORD1\n                        // #define VARYINGS_NEED_TEXCOORD2\n                       
      // #define VARYINGS_NEED_TEXCOORD3\n                        // #define VARYINGS_NEED_COLOR\n                       
      // #define VARYINGS_NEED_CULLFACE\n                        // #define HAVE_MESH_MODIFICATION\n                   
      \n                    // We need isFontFace when using double sided\n                   
      #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n                       
      #define VARYINGS_NEED_CULLFACE\n                    #endif\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      WorldSpaceNormal; // optional\n                                    float3 TangentSpaceNormal;
      // optional\n                                    float3 WorldSpaceTangent;
      // optional\n                                    float3 WorldSpaceBiTangent;
      // optional\n                                    float3 WorldSpacePosition;
      // optional\n                                    float4 uv0; // optional\n                                   
      #if UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float3 Albedo;\n                                   
      float3 Normal;\n                                    float3 BentNormal;\n                                   
      float3 HairStrandDirection;\n                                    float3 Transmittance;\n                                   
      float RimTransmissionIntensity;\n                                    float
      Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                    float3 SpecularTint;\n                                   
      float SpecularShift;\n                                    float3 SecondarySpecularTint;\n                                   
      float SecondarySmoothness;\n                                    float SecondarySpecularShift;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n                            \n               
      inline float2 Unity_Voronoi_RandomVector_float (float2 UV, float offset)\n               
      {\n                    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);\n                   
      UV = frac(sin(mul(UV, m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n                               
      void Unity_NormalFromHeight_Tangent_float(float In, float3 Position, float3x3
      TangentMatrix, out float3 Out)\n                                {\n                                   
      float3 worldDirivativeX = ddx(Position * 100);\n                                   
      float3 worldDirivativeY = ddy(Position * 100);\n                           
      \n                                    float3 crossX = cross(TangentMatrix[2].xyz,
      worldDirivativeX);\n                                    float3 crossY = cross(TangentMatrix[2].xyz,
      worldDirivativeY);\n                                    float3 d = abs(dot(crossY,
      worldDirivativeX));\n                                    float3 inToNormal
      = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d);\n                                   
      inToNormal.y *= -1.0;\n                            \n                                   
      Out = normalize((d * TangentMatrix[2].xyz) - inToNormal);\n                                   
      Out = TransformWorldToTangent(Out, TangentMatrix);\n                               
      }\n                            \n            ByteAddressBuffer attributeBuffer;\n           
      SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS
      vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 Color_984B4A4D = IsGammaSpace() ? float4(0.9622642, 0.5395483, 0.2224101,
      0.8509804) : float4(SRGBToLinear(float3(0.9622642, 0.5395483, 0.2224101)),
      0.8509804);\n                                    float4 _UV_1375B2FB_Out_0
      = IN.uv0;\n                                    float4 _Multiply_ADE6D21B_Out_2;\n                                   
      Unity_Multiply_float(_UV_1375B2FB_Out_0, float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    float4 _Multiply_E72CAE5B_Out_2;\n                                   
      Unity_Multiply_float(Color_984B4A4D, (_Voronoi_71091390_Out_3.xxxx), _Multiply_E72CAE5B_Out_2);\n                                   
      float3 _NormalFromHeight_59319239_Out_1;\n                                   
      float3x3 _NormalFromHeight_59319239_TangentMatrix = float3x3(IN.WorldSpaceTangent,
      IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n                                   
      float3 _NormalFromHeight_59319239_Position = IN.WorldSpacePosition;\n                                   
      Unity_NormalFromHeight_Tangent_float(_Voronoi_71091390_Out_3,_NormalFromHeight_59319239_Position,_NormalFromHeight_59319239_TangentMatrix,
      _NormalFromHeight_59319239_Out_1);\n                                    surface.Albedo
      = (_Multiply_E72CAE5B_Out_2.xyz);\n                                    surface.Normal
      = _NormalFromHeight_59319239_Out_1;\n                                    surface.BentNormal
      = IN.TangentSpaceNormal;\n                                    surface.HairStrandDirection
      = float3 (0, -1, 0);\n                                    surface.Transmittance
      = float3 (0.3, 0.195, 0.09);\n                                    surface.RimTransmissionIntensity
      = 0.2;\n                                    surface.Smoothness = 0.5;\n                                   
      surface.Occlusion = 1;\n                                    surface.Alpha =
      1;\n                                    surface.SpecularTint = IsGammaSpace()
      ? float3(1, 1, 1) : SRGBToLinear(float3(1, 1, 1));\n                                   
      surface.SpecularShift = 0.1;\n                                    surface.SecondarySpecularTint
      = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5, 0.5, 0.5));\n                                   
      surface.SecondarySmoothness = 0.5;\n                                    surface.SecondarySpecularShift
      = -0.1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            surfaceData.specularTint =                  surfaceDescription.SpecularTint;\n                           
      surfaceData.specularShift =                 surfaceDescription.SpecularShift;\n                   
      \n                            surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      Blend One Zero\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        // #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            //
      normalTS = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        // #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescription.Alpha\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      surface.Alpha = 1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            //
      normalTS = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            ZWrite On\n           
      Stencil\n            {\n                WriteMask 48\n                Ref 0\n               
      Comp Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                        #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        // #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   SurfaceDescriptionInputs.WorldSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.WorldSpaceTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpaceBiTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpacePosition\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      WorldSpaceNormal; // optional\n                                    float3 TangentSpaceNormal;
      // optional\n                                    float3 WorldSpaceTangent;
      // optional\n                                    float3 WorldSpaceBiTangent;
      // optional\n                                    float3 WorldSpacePosition;
      // optional\n                                    float4 uv0; // optional\n                                   
      #if UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float3 Normal;\n                                   
      float Smoothness;\n                                    float Alpha;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n                            \n               
      inline float2 Unity_Voronoi_RandomVector_float (float2 UV, float offset)\n               
      {\n                    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);\n                   
      UV = frac(sin(mul(UV, m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n                               
      void Unity_NormalFromHeight_Tangent_float(float In, float3 Position, float3x3
      TangentMatrix, out float3 Out)\n                                {\n                                   
      float3 worldDirivativeX = ddx(Position * 100);\n                                   
      float3 worldDirivativeY = ddy(Position * 100);\n                           
      \n                                    float3 crossX = cross(TangentMatrix[2].xyz,
      worldDirivativeX);\n                                    float3 crossY = cross(TangentMatrix[2].xyz,
      worldDirivativeY);\n                                    float3 d = abs(dot(crossY,
      worldDirivativeX));\n                                    float3 inToNormal
      = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d);\n                                   
      inToNormal.y *= -1.0;\n                            \n                                   
      Out = normalize((d * TangentMatrix[2].xyz) - inToNormal);\n                                   
      Out = TransformWorldToTangent(Out, TangentMatrix);\n                               
      }\n                            \n            ByteAddressBuffer attributeBuffer;\n           
      SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS
      vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_1375B2FB_Out_0 = IN.uv0;\n                                    float4
      _Multiply_ADE6D21B_Out_2;\n                                    Unity_Multiply_float(_UV_1375B2FB_Out_0,
      float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    float3 _NormalFromHeight_59319239_Out_1;\n                                   
      float3x3 _NormalFromHeight_59319239_TangentMatrix = float3x3(IN.WorldSpaceTangent,
      IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n                                   
      float3 _NormalFromHeight_59319239_Position = IN.WorldSpacePosition;\n                                   
      Unity_NormalFromHeight_Tangent_float(_Voronoi_71091390_Out_3,_NormalFromHeight_59319239_Position,_NormalFromHeight_59319239_TangentMatrix,
      _NormalFromHeight_59319239_Out_1);\n                                    surface.Normal
      = _NormalFromHeight_59319239_Out_1;\n                                    surface.Smoothness
      = 0.5;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Stencil\n           
      {\n                WriteMask 176\n                Ref 128\n               
      Comp Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                        #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        // #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   SurfaceDescriptionInputs.WorldSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.WorldSpaceTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpaceBiTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpacePosition\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      WorldSpaceNormal; // optional\n                                    float3 TangentSpaceNormal;
      // optional\n                                    float3 WorldSpaceTangent;
      // optional\n                                    float3 WorldSpaceBiTangent;
      // optional\n                                    float3 WorldSpacePosition;
      // optional\n                                    float4 uv0; // optional\n                                   
      #if UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float3 Normal;\n                                   
      float Smoothness;\n                                    float Alpha;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n                            \n               
      inline float2 Unity_Voronoi_RandomVector_float (float2 UV, float offset)\n               
      {\n                    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);\n                   
      UV = frac(sin(mul(UV, m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n                               
      void Unity_NormalFromHeight_Tangent_float(float In, float3 Position, float3x3
      TangentMatrix, out float3 Out)\n                                {\n                                   
      float3 worldDirivativeX = ddx(Position * 100);\n                                   
      float3 worldDirivativeY = ddy(Position * 100);\n                           
      \n                                    float3 crossX = cross(TangentMatrix[2].xyz,
      worldDirivativeX);\n                                    float3 crossY = cross(TangentMatrix[2].xyz,
      worldDirivativeY);\n                                    float3 d = abs(dot(crossY,
      worldDirivativeX));\n                                    float3 inToNormal
      = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d);\n                                   
      inToNormal.y *= -1.0;\n                            \n                                   
      Out = normalize((d * TangentMatrix[2].xyz) - inToNormal);\n                                   
      Out = TransformWorldToTangent(Out, TangentMatrix);\n                               
      }\n                            \n            ByteAddressBuffer attributeBuffer;\n           
      SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS
      vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_1375B2FB_Out_0 = IN.uv0;\n                                    float4
      _Multiply_ADE6D21B_Out_2;\n                                    Unity_Multiply_float(_UV_1375B2FB_Out_0,
      float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    float3 _NormalFromHeight_59319239_Out_1;\n                                   
      float3x3 _NormalFromHeight_59319239_TangentMatrix = float3x3(IN.WorldSpaceTangent,
      IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n                                   
      float3 _NormalFromHeight_59319239_Position = IN.WorldSpacePosition;\n                                   
      Unity_NormalFromHeight_Tangent_float(_Voronoi_71091390_Out_3,_NormalFromHeight_59319239_Position,_NormalFromHeight_59319239_TangentMatrix,
      _NormalFromHeight_59319239_Out_1);\n                                    surface.Normal
      = _NormalFromHeight_59319239_Out_1;\n                                    surface.Smoothness
      = 0.5;\n                                    surface.Alpha = 1;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ForwardOnly\"\n           
      Tags {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n           
      ZTest Equal\n            ZWrite On\n            ColorMask RGBA 1\n           
      Blend One Zero, One OneMinusSrcAlpha\n            Stencil\n            {\n               
      WriteMask 3\n                Ref 2\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                        #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        // #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING
      1\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #pragma multi_compile
      USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n                            #pragma
      multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   SurfaceDescriptionInputs.WorldSpaceNormal\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.WorldSpaceTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpaceBiTangent\n                           
      //   SurfaceDescriptionInputs.WorldSpacePosition\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.HairStrandDirection\n                            //  
      SurfaceDescription.Transmittance\n                            //   SurfaceDescription.RimTransmissionIntensity\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.SpecularTint\n                           
      //   SurfaceDescription.SpecularShift\n                            //   SurfaceDescription.SecondarySpecularTint\n                           
      //   SurfaceDescription.SecondarySmoothness\n                            //  
      SurfaceDescription.SecondarySpecularShift\n                            //  
      AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      WorldSpaceNormal; // optional\n                                    float3 TangentSpaceNormal;
      // optional\n                                    float3 WorldSpaceTangent;
      // optional\n                                    float3 WorldSpaceBiTangent;
      // optional\n                                    float3 WorldSpacePosition;
      // optional\n                                    float4 uv0; // optional\n                                   
      #if UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float3 Albedo;\n                                   
      float3 Normal;\n                                    float3 BentNormal;\n                                   
      float3 HairStrandDirection;\n                                    float3 Transmittance;\n                                   
      float RimTransmissionIntensity;\n                                    float
      Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                    float3 SpecularTint;\n                                   
      float SpecularShift;\n                                    float3 SecondarySpecularTint;\n                                   
      float SecondarySmoothness;\n                                    float SecondarySpecularShift;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n                            \n               
      inline float2 Unity_Voronoi_RandomVector_float (float2 UV, float offset)\n               
      {\n                    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);\n                   
      UV = frac(sin(mul(UV, m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n                               
      void Unity_NormalFromHeight_Tangent_float(float In, float3 Position, float3x3
      TangentMatrix, out float3 Out)\n                                {\n                                   
      float3 worldDirivativeX = ddx(Position * 100);\n                                   
      float3 worldDirivativeY = ddy(Position * 100);\n                           
      \n                                    float3 crossX = cross(TangentMatrix[2].xyz,
      worldDirivativeX);\n                                    float3 crossY = cross(TangentMatrix[2].xyz,
      worldDirivativeY);\n                                    float3 d = abs(dot(crossY,
      worldDirivativeX));\n                                    float3 inToNormal
      = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d);\n                                   
      inToNormal.y *= -1.0;\n                            \n                                   
      Out = normalize((d * TangentMatrix[2].xyz) - inToNormal);\n                                   
      Out = TransformWorldToTangent(Out, TangentMatrix);\n                               
      }\n                            \n            ByteAddressBuffer attributeBuffer;\n           
      SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS
      vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 Color_984B4A4D = IsGammaSpace() ? float4(0.9622642, 0.5395483, 0.2224101,
      0.8509804) : float4(SRGBToLinear(float3(0.9622642, 0.5395483, 0.2224101)),
      0.8509804);\n                                    float4 _UV_1375B2FB_Out_0
      = IN.uv0;\n                                    float4 _Multiply_ADE6D21B_Out_2;\n                                   
      Unity_Multiply_float(_UV_1375B2FB_Out_0, float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    float4 _Multiply_E72CAE5B_Out_2;\n                                   
      Unity_Multiply_float(Color_984B4A4D, (_Voronoi_71091390_Out_3.xxxx), _Multiply_E72CAE5B_Out_2);\n                                   
      float3 _NormalFromHeight_59319239_Out_1;\n                                   
      float3x3 _NormalFromHeight_59319239_TangentMatrix = float3x3(IN.WorldSpaceTangent,
      IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n                                   
      float3 _NormalFromHeight_59319239_Position = IN.WorldSpacePosition;\n                                   
      Unity_NormalFromHeight_Tangent_float(_Voronoi_71091390_Out_3,_NormalFromHeight_59319239_Position,_NormalFromHeight_59319239_TangentMatrix,
      _NormalFromHeight_59319239_Out_1);\n                                    surface.Albedo
      = (_Multiply_E72CAE5B_Out_2.xyz);\n                                    surface.Normal
      = _NormalFromHeight_59319239_Out_1;\n                                    surface.BentNormal
      = IN.TangentSpaceNormal;\n                                    surface.HairStrandDirection
      = float3 (0, -1, 0);\n                                    surface.Transmittance
      = float3 (0.3, 0.195, 0.09);\n                                    surface.RimTransmissionIntensity
      = 0.2;\n                                    surface.Smoothness = 0.5;\n                                   
      surface.Occlusion = 1;\n                                    surface.Alpha =
      1;\n                                    surface.SpecularTint = IsGammaSpace()
      ? float3(1, 1, 1) : SRGBToLinear(float3(1, 1, 1));\n                                   
      surface.SpecularShift = 0.1;\n                                    surface.SecondarySpecularTint
      = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5, 0.5, 0.5));\n                                   
      surface.SecondarySmoothness = 0.5;\n                                    surface.SecondarySpecularShift
      = -0.1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            surfaceData.specularTint =                  surfaceDescription.SpecularTint;\n                           
      surfaceData.specularShift =                 surfaceDescription.SpecularShift;\n                   
      \n                            surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 2]Shader Graph Mesh Output'
    source: "Shader \"Hidden/VFX/HDRPlit/System 2/Shader Graph Mesh Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Transparent+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.HairStrandDirection\n                            //  
      SurfaceDescription.Transmittance\n                            //   SurfaceDescription.RimTransmissionIntensity\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.SpecularTint\n                           
      //   SurfaceDescription.SpecularShift\n                            //   SurfaceDescription.SecondarySpecularTint\n                           
      //   SurfaceDescription.SecondarySmoothness\n                            //  
      SurfaceDescription.SecondarySpecularShift\n                            //  
      AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float3 HairStrandDirection;\n                                   
      float3 Transmittance;\n                                    float RimTransmissionIntensity;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                    float3 SpecularTint;\n                                   
      float SpecularShift;\n                                    float3 SecondarySpecularTint;\n                                   
      float SecondarySmoothness;\n                                    float SecondarySpecularShift;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n                            \n               
      inline float2 Unity_Voronoi_RandomVector_float (float2 UV, float offset)\n               
      {\n                    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);\n                   
      UV = frac(sin(mul(UV, m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 Color_984B4A4D = IsGammaSpace() ? float4(0.9622642, 0.5395483, 0.2224101,
      0.8509804) : float4(SRGBToLinear(float3(0.9622642, 0.5395483, 0.2224101)),
      0.8509804);\n                                    float4 _UV_1375B2FB_Out_0
      = IN.uv0;\n                                    float4 _Multiply_ADE6D21B_Out_2;\n                                   
      Unity_Multiply_float(_UV_1375B2FB_Out_0, float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    float4 _Multiply_E72CAE5B_Out_2;\n                                   
      Unity_Multiply_float(Color_984B4A4D, (_Voronoi_71091390_Out_3.xxxx), _Multiply_E72CAE5B_Out_2);\n                                   
      surface.Albedo = (_Multiply_E72CAE5B_Out_2.xyz);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.HairStrandDirection = float3 (0, -1, 0);\n                                   
      surface.Transmittance = float3 (0.3, 0.195, 0.09);\n                                   
      surface.RimTransmissionIntensity = 0.2;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = _Voronoi_71091390_Out_3;\n                                   
      surface.SpecularTint = IsGammaSpace() ? float3(1, 1, 1) : SRGBToLinear(float3(1,
      1, 1));\n                                    surface.SpecularShift = 0.1;\n                                   
      surface.SecondarySpecularTint = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5,
      0.5, 0.5));\n                                    surface.SecondarySmoothness
      = 0.5;\n                                    surface.SecondarySpecularShift
      = -0.1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            surfaceData.specularTint =                  surfaceDescription.SpecularTint;\n                           
      surfaceData.specularShift =                 surfaceDescription.SpecularShift;\n                   
      \n                            surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      Blend One Zero\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float4 uv0 : TEXCOORD0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_1375B2FB_Out_0 = IN.uv0;\n                                    float4
      _Multiply_ADE6D21B_Out_2;\n                                    Unity_Multiply_float(_UV_1375B2FB_Out_0,
      float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    surface.Alpha
      = _Voronoi_71091390_Out_3;\n                                    surface.Alpha
      *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            //
      normalTS = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        #pragma multi_compile_instancing\n                       
      #pragma instancing_options renderinglayer\n                    \n                       
      #pragma multi_compile _ LOD_FADE_CROSSFADE\n                    \n                       
      #pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Alpha\n                           
      //   FragInputs.texCoord0\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   AttributesMesh.uv0\n                    \n                        // this
      translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float4 uv0 : TEXCOORD0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float4 texCoord0; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyzw = input.texCoord0;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.texCoord0
      = input.interp00.xyzw;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_1375B2FB_Out_0 = IN.uv0;\n                                    float4
      _Multiply_ADE6D21B_Out_2;\n                                    Unity_Multiply_float(_UV_1375B2FB_Out_0,
      float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    surface.Alpha
      = _Voronoi_71091390_Out_3;\n                                    surface.Alpha
      *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      // surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            //
      normalTS = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            ZWrite On\n           
      Stencil\n            {\n                WriteMask 48\n                Ref 0\n               
      Comp Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                        #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_1375B2FB_Out_0 = IN.uv0;\n                                    float4
      _Multiply_ADE6D21B_Out_2;\n                                    Unity_Multiply_float(_UV_1375B2FB_Out_0,
      float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    surface.Normal
      = IN.TangentSpaceNormal;\n                                    surface.Smoothness
      = 0.5;\n                                    surface.Alpha = _Voronoi_71091390_Out_3;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Stencil\n           
      {\n                WriteMask 176\n                Ref 128\n               
      Comp Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                        #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #define
      WRITE_NORMAL_BUFFER\n                            #pragma multi_compile _ WRITE_MSAA_DEPTH\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Normal\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Alpha\n                           
      //   AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Normal;\n                                    float Smoothness;\n                                   
      float Alpha;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n                           
      \n                                void Unity_Multiply_float (float4 A, float4
      B, out float4 Out)\n                                {\n                                   
      Out = A * B;\n                                }\n                           
      \n                            \n                inline float2 Unity_Voronoi_RandomVector_float
      (float2 UV, float offset)\n                {\n                    float2x2
      m = float2x2(15.27, 47.63, 99.41, 89.98);\n                    UV = frac(sin(mul(UV,
      m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 _UV_1375B2FB_Out_0 = IN.uv0;\n                                    float4
      _Multiply_ADE6D21B_Out_2;\n                                    Unity_Multiply_float(_UV_1375B2FB_Out_0,
      float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    surface.Normal
      = IN.TangentSpaceNormal;\n                                    surface.Smoothness
      = 0.5;\n                                    surface.Alpha = _Voronoi_71091390_Out_3;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      // surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      // surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      // surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            // surfaceData.specularTint =                 
      surfaceDescription.SpecularTint;\n                            // surfaceData.specularShift
      =                 surfaceDescription.SpecularShift;\n                    \n                           
      // surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      // surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      // surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ForwardOnly\"\n           
      Tags {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n           
      ZTest LEqual\n            ZWrite Off\n            ColorMask RGBA 1\n           
      Blend One OneMinusSrcAlpha, One OneMinusSrcAlpha\n            Stencil\n           
      {\n                WriteMask 3\n                Ref 2\n                Comp
      Always\n                Pass Replace\n            }\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      #pragma multi_compile_instancing\n                        #pragma instancing_options
      renderinglayer\n                    \n                        #pragma multi_compile
      _ LOD_FADE_CROSSFADE\n                    \n                        #pragma
      shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                       
      #pragma shader_feature_local _DOUBLESIDED_ON\n                        #pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant Definitions (active field translations to HDRP defines)\n                       
      //-------------------------------------------------------------------------------------\n                       
      #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1\n                        #define
      _ENABLE_FOG_ON_TRANSPARENT 1\n                        // #define _OCCLUSION
      1\n                        // #define _SPECULAR_OCCLUSION_FROM_AO 1\n                       
      // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n                       
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n                        // #define
      _ENABLE_GEOMETRIC_SPECULAR_AA 1\n                        // #define _DISABLE_DECALS
      1\n                        // #define _DISABLE_SSR 1\n                       
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n                        // #define
      _DEPTHOFFSET_ON 1\n                        // #define _USE_LIGHT_FACING_NORMAL
      1\n                        #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n                   
      \n                        // define FragInputs structure\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            #pragma multi_compile
      _ LIGHTMAP_ON\n                            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                            #pragma
      multi_compile _ SHADOWS_SHADOWMASK\n                            #pragma multi_compile
      DECALS_OFF DECALS_3RT DECALS_4RT\n                            #define USE_CLUSTERED_LIGHTLIST\n                           
      #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n                           
      // ACTIVE FIELDS:\n                            //   Material.KajiyaKay\n                           
      //   AlphaFog\n                            //   BlendMode.PreserveSpecular\n                           
      //   SurfaceDescriptionInputs.TangentSpaceNormal\n                           
      //   SurfaceDescriptionInputs.uv0\n                            //   SurfaceDescription.Albedo\n                           
      //   SurfaceDescription.Normal\n                            //   SurfaceDescription.BentNormal\n                           
      //   SurfaceDescription.HairStrandDirection\n                            //  
      SurfaceDescription.Transmittance\n                            //   SurfaceDescription.RimTransmissionIntensity\n                           
      //   SurfaceDescription.Smoothness\n                            //   SurfaceDescription.Occlusion\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.SpecularTint\n                           
      //   SurfaceDescription.SpecularShift\n                            //   SurfaceDescription.SecondarySpecularTint\n                           
      //   SurfaceDescription.SecondarySmoothness\n                            //  
      SurfaceDescription.SecondarySpecularShift\n                            //  
      AttributesMesh.normalOS\n                            //   AttributesMesh.tangentOS\n                           
      //   AttributesMesh.uv0\n                            //   AttributesMesh.uv1\n                           
      //   AttributesMesh.color\n                            //   AttributesMesh.uv2\n                           
      //   AttributesMesh.uv3\n                            //   FragInputs.tangentToWorld\n                           
      //   FragInputs.positionRWS\n                            //   FragInputs.texCoord0\n                           
      //   FragInputs.texCoord1\n                            //   FragInputs.texCoord2\n                           
      //   FragInputs.texCoord3\n                            //   FragInputs.color\n                           
      //   VaryingsMeshToPS.tangentWS\n                            //   VaryingsMeshToPS.normalWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   VaryingsMeshToPS.texCoord0\n                           
      //   VaryingsMeshToPS.texCoord1\n                            //   VaryingsMeshToPS.texCoord2\n                           
      //   VaryingsMeshToPS.texCoord3\n                            //   VaryingsMeshToPS.color\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        #define ATTRIBUTES_NEED_NORMAL\n                       
      #define ATTRIBUTES_NEED_TANGENT\n                        #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      #define ATTRIBUTES_NEED_TEXCOORD1\n                        #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      #define ATTRIBUTES_NEED_TEXCOORD3\n                        #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      #define VARYINGS_NEED_TEXCOORD0\n                        #define VARYINGS_NEED_TEXCOORD1\n                       
      #define VARYINGS_NEED_TEXCOORD2\n                        #define VARYINGS_NEED_TEXCOORD3\n                       
      #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                   
      // We need isFontFace when using double sided\n                    #if defined(_DOUBLESIDED_ON)
      && !defined(VARYINGS_NEED_CULLFACE)\n                        #define VARYINGS_NEED_CULLFACE\n                   
      #endif\n                    \n                        //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                   
      #ifdef DEBUG_DISPLAY\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                   
      \n                    #if (SHADERPASS == SHADERPASS_FORWARD)\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n                   
      \n                        #define HAS_LIGHTLOOP\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n                   
      #else\n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl\"\n                   
      #endif\n                    \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        //Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 uv3 : TEXCOORD3;
      // optional\n                        float4 color : COLOR; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        float3 normalWS; //
      optional\n                        float4 tangentWS; // optional\n                       
      float4 texCoord0; // optional\n                        float4 texCoord1; //
      optional\n                        float4 texCoord2; // optional\n                       
      float4 texCoord3; // optional\n                        float4 color; // optional\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float3 interp01 : TEXCOORD1;
      // auto-packed\n                        float4 interp02 : TEXCOORD2; // auto-packed\n                       
      float4 interp03 : TEXCOORD3; // auto-packed\n                        float4
      interp04 : TEXCOORD4; // auto-packed\n                        float4 interp05
      : TEXCOORD5; // auto-packed\n                        float4 interp06 : TEXCOORD6;
      // auto-packed\n                        float4 interp07 : TEXCOORD7; // auto-packed\n                       
      float4 positionCS : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        output.interp02.xyzw = input.tangentWS;\n                       
      output.interp03.xyzw = input.texCoord0;\n                        output.interp04.xyzw
      = input.texCoord1;\n                        output.interp05.xyzw = input.texCoord2;\n                       
      output.interp06.xyzw = input.texCoord3;\n                        output.interp07.xyzw
      = input.color;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        output.normalWS = input.interp01.xyz;\n                       
      output.tangentWS = input.interp02.xyzw;\n                        output.texCoord0
      = input.interp03.xyzw;\n                        output.texCoord1 = input.interp04.xyzw;\n                       
      output.texCoord2 = input.interp05.xyzw;\n                        output.texCoord3
      = input.interp06.xyzw;\n                        output.color = input.interp07.xyzw;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      TangentSpaceNormal; // optional\n                                    float4
      uv0; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Albedo;\n                                    float3 Normal;\n                                   
      float3 BentNormal;\n                                    float3 HairStrandDirection;\n                                   
      float3 Transmittance;\n                                    float RimTransmissionIntensity;\n                                   
      float Smoothness;\n                                    float Occlusion;\n                                   
      float Alpha;\n                                    float3 SpecularTint;\n                                   
      float SpecularShift;\n                                    float3 SecondarySpecularTint;\n                                   
      float SecondarySmoothness;\n                                    float SecondarySpecularShift;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_Multiply_float (float4 A, float4 B, out float4 Out)\n                               
      {\n                                    Out = A * B;\n                               
      }\n                            \n                            \n               
      inline float2 Unity_Voronoi_RandomVector_float (float2 UV, float offset)\n               
      {\n                    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);\n                   
      UV = frac(sin(mul(UV, m)) * 46839.32);\n                    return float2(sin(UV.y*+offset)*0.5+0.5,
      cos(UV.x*offset)*0.5+0.5);\n                }\n            \n                               
      void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out
      float Out, out float Cells)\n                                {\n                                   
      float2 g = floor(UV * CellDensity);\n                                    float2
      f = frac(UV * CellDensity);\n                                    float t =
      8.0;\n                                    float3 res = float3(8.0, 0.0, 0.0);\n                           
      \n                                    for(int y=-1; y<=1; y++)\n                                   
      {\n                                        for(int x=-1; x<=1; x++)\n                                       
      {\n                                            float2 lattice = float2(x,y);\n                                           
      float2 offset = Unity_Voronoi_RandomVector_float(lattice + g, AngleOffset);\n                                           
      float d = distance(lattice + offset, f);\n                            \n                                           
      if(d < res.x)\n                                            {\n                                               
      res = float3(d, offset.x, offset.y);\n                                               
      Out = res.x;\n                                                Cells = res.y;\n                                           
      }\n                                        }\n                                   
      }\n                                }\n                            \n           
      ByteAddressBuffer attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n                                   
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n                                   
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (bool)true;\n                                   
      float3 axisX = float3(1,0,0);\n                                    float3 axisY
      = float3(0,1,0);\n                                    float3 axisZ = float3(0,0,1);\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            uint particleId
      = index;\n            \n\n    if( !alive) discard;\n    \n                                   
      SurfaceDescription surface = (SurfaceDescription)0;\n                                   
      float4 Color_984B4A4D = IsGammaSpace() ? float4(0.9622642, 0.5395483, 0.2224101,
      0.8509804) : float4(SRGBToLinear(float3(0.9622642, 0.5395483, 0.2224101)),
      0.8509804);\n                                    float4 _UV_1375B2FB_Out_0
      = IN.uv0;\n                                    float4 _Multiply_ADE6D21B_Out_2;\n                                   
      Unity_Multiply_float(_UV_1375B2FB_Out_0, float4(12, 1, 2, 2), _Multiply_ADE6D21B_Out_2);\n                                   
      float _Voronoi_71091390_Out_3;\n                                    float _Voronoi_71091390_Cells_4;\n                                   
      Unity_Voronoi_float((_Multiply_ADE6D21B_Out_2.xy), 2, 5, _Voronoi_71091390_Out_3,
      _Voronoi_71091390_Cells_4);\n                                    float4 _Multiply_E72CAE5B_Out_2;\n                                   
      Unity_Multiply_float(Color_984B4A4D, (_Voronoi_71091390_Out_3.xxxx), _Multiply_E72CAE5B_Out_2);\n                                   
      surface.Albedo = (_Multiply_E72CAE5B_Out_2.xyz);\n                                   
      surface.Normal = IN.TangentSpaceNormal;\n                                   
      surface.BentNormal = IN.TangentSpaceNormal;\n                                   
      surface.HairStrandDirection = float3 (0, -1, 0);\n                                   
      surface.Transmittance = float3 (0.3, 0.195, 0.09);\n                                   
      surface.RimTransmissionIntensity = 0.2;\n                                   
      surface.Smoothness = 0.5;\n                                    surface.Occlusion
      = 1;\n                                    surface.Alpha = _Voronoi_71091390_Out_3;\n                                   
      surface.SpecularTint = IsGammaSpace() ? float3(1, 1, 1) : SRGBToLinear(float3(1,
      1, 1));\n                                    surface.SpecularShift = 0.1;\n                                   
      surface.SecondarySpecularTint = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5,
      0.5, 0.5));\n                                    surface.SecondarySmoothness
      = 0.5;\n                                    surface.SecondarySpecularShift
      = -0.1;\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      output.texCoord0 = input.texCoord0;\n                            output.texCoord1
      = input.texCoord1;\n                            output.texCoord2 = input.texCoord2;\n                           
      output.texCoord3 = input.texCoord3;\n                            output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void ApplyDecalToSurfaceData(DecalSurfaceData
      decalSurfaceData, inout SurfaceData surfaceData)\n                        {\n                           
      // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html\n                           
      if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_DIFFUSE)\n                           
      {\n                                surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz
      * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;\n                           
      }\n                    \n                            if (decalSurfaceData.HTileMask
      & DBUFFERHTILEBIT_NORMAL)\n                            {\n                               
      surfaceData.normalWS.xyz = normalize(surfaceData.normalWS.xyz * decalSurfaceData.normalWS.w
      + decalSurfaceData.normalWS.xyz);\n                            }\n                   
      \n                            if (decalSurfaceData.HTileMask & DBUFFERHTILEBIT_MASK)\n                           
      {\n                        #ifdef DECALS_4RT // only smoothness in 3RT mode\n                               
      // Don't apply any metallic modification\n                                surfaceData.ambientOcclusion
      = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;\n                       
      #endif\n                    \n                                surfaceData.perceptualSmoothness
      = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;\n                           
      }\n                        }\n                    \n                       
      void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n                        {\n                            // setup
      defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.diffuseColor
      =                  surfaceDescription.Albedo;\n                           
      // surfaceData.specularOcclusion =             surfaceDescription.SpecularOcclusion;\n                           
      surfaceData.perceptualSmoothness =          surfaceDescription.Smoothness;\n                           
      surfaceData.ambientOcclusion =              surfaceDescription.Occlusion;\n                           
      surfaceData.transmittance =                 surfaceDescription.Transmittance;\n                           
      surfaceData.rimTransmissionIntensity =      surfaceDescription.RimTransmissionIntensity;\n                   
      \n                            surfaceData.specularTint =                  surfaceDescription.SpecularTint;\n                           
      surfaceData.specularShift =                 surfaceDescription.SpecularShift;\n                   
      \n                            surfaceData.secondaryPerceptualSmoothness = surfaceDescription.SecondarySmoothness;\n                           
      surfaceData.secondarySpecularTint =         surfaceDescription.SecondarySpecularTint;\n                           
      surfaceData.secondarySpecularShift =        surfaceDescription.SecondarySpecularShift;\n                        
      \n                            // These static material feature allow compile
      time optimization\n                            surfaceData.materialFeatures
      = 0;\n                    \n                            // Transform the preprocess
      macro into a material feature\n                    #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY\n                           
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;\n                   
      #endif\n                    \n                    #ifdef _DOUBLESIDED_ON\n                       
      float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                   
      #else\n                        float3 doubleSidedConstants = float3(1.0, 1.0,
      1.0);\n                    #endif\n                    \n                           
      // For a typical Unity quad, you have tangent vectors pointing to the right
      (X axis),\n                            // and bitangent vectors pointing up
      (Y axis).\n                            // The current hair setup uses mesh
      cards (e.g. quads).\n                            // Hair is usually painted
      top-down, from the root to the tip.\n                            // Therefore,
      DefaultHairStrandTangent = -MeshCardBitangent.\n                           
      // Both the SurfaceData and the BSDFData store the hair tangent\n                           
      // (which represents the hair strand direction, root to tip).\n                           
      surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;\n                           
      // The hair strand direction texture contains tangent-space vectors.\n                           
      // We use the same convention for the texture, which means that\n                           
      // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),\n                           
      // the artist has to paint (0, -1, 0).\n                            // TODO:
      pending artist feedback...\n                            // surfaceData.hairStrandDirectionWS
      = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);\n                           
      // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.\n                           
      // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),\n                           
      // we may as well not bother to orthonormalize anymore.\n                           
      // The tangent should still be a unit vector, though.\n                           
      surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);\n                   
      \n                            // Small digression about hair and normals [NOTE-HAIR-NORMALS].\n                           
      // Since a hair strand is (approximately) a cylinder,\n                           
      // there is a whole \"circle\" of normals corresponding to any given tangent
      vector.\n                            // Since we use the Kajiya-Kay shading
      model,\n                            // the way we compute and use normals is
      a bit complicated.\n                            // We need 4 separate sets
      of normals.\n                            // For shadow bias, we use the geometric
      normal.\n                            // For direct lighting, we either (conceptually)
      use the \"light-facing\" normal\n                            // or the user-provided
      normal.\n                            // For reflected GI (light probes and
      reflection probes), we use the normal most aligned\n                           
      // with the view vector (the \"view-facing\" normal), or the user-provided
      normal.\n                            // We reflect this normal for transmitted
      GI.\n                            // For the highlight shift hack (along the
      tangent), we use the user-provided normal.\n                    \n                           
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n                   
      \n                            // tangent-space normal\n                           
      float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                            normalTS
      = surfaceDescription.Normal;\n                    \n                           
      // compute world space (user-provided) normal\n                           
      GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                   
      \n                        #if (_USE_LIGHT_FACING_NORMAL)\n                           
      float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);\n                           
      float3 N = viewFacingNormalWS;\n                        #else\n                           
      float3 N = surfaceData.normalWS;\n                        #endif\n                   
      \n                            bentNormalWS = N;\n                    \n                           
      // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n                   
      \n                            // By default we use the ambient occlusion with
      Tri-ace trick (apply outside) for specular occlusion.\n                           
      // If user provide bent normal then we process a better term\n                           
      surfaceData.specularOcclusion = 1.0;\n                    \n                   
      #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                            // Just
      use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                           
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                           
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #else\n                            surfaceData.specularOcclusion = 1.0;\n                   
      #endif\n                    \n                    #if HAVE_DECALS\n                           
      if (_EnableDecals)\n                            {\n                               
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                               
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                           
      }\n                    #endif\n                    \n                    #ifdef
      _ENABLE_GEOMETRIC_SPECULAR_AA\n                            surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n                    \n                    #ifdef DEBUG_DISPLAY\n                           
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                           
      {\n                                // TODO: need to update mip info\n                           
      }\n                    \n                            // We need to call ApplyDebugToSurfaceData
      after filling the surfarcedata and before filling builtinData\n                           
      // as it can modify attribute use for static lighting\n                           
      ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                   
      #endif\n                        }\n                    \n                       
      void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs
      posInput, out SurfaceData surfaceData, out BuiltinData builtinData)\n                       
      {\n                    #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition
      if user select CrossFade transition in LOD group\n                           
      uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to
      _ScreenSize values\n                            LODDitheringTransition(fadeMaskSeed,
      unity_LODFade.x);\n                    #endif\n                    \n                   
      #ifdef _DOUBLESIDED_ON\n                        float3 doubleSidedConstants
      = _DoubleSidedConstants.xyz;\n                    #else\n                       
      float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                    #endif\n                   
      \n                            ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n                   
      \n                            SurfaceDescriptionInputs surfaceDescriptionInputs
      = FragInputsToSurfaceDescriptionInputs(fragInputs, V);\n            SurfaceDescription
      surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPrepass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdDepthPostpass);\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThresholdShadow);\n                   
      \n                            // ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset,
      GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);\n                   
      \n                            float3 bentNormalWS;\n                           
      BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData,
      bentNormalWS);\n                        \n                            // Builtin
      Data\n                            // For back lighting we use the oposite vertex
      normal \n                            InitBuiltinData(posInput, surfaceDescription.Alpha,
      bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n                    \n                            // override
      sampleBakedGI:\n                            // builtinData.bakeDiffuseLighting
      = surfaceDescription.BakedGI;\n                            // builtinData.backBakeDiffuseLighting
      = surfaceDescription.BakedBackGI;\n                    \n                           
      // builtinData.depthOffset = surfaceDescription.DepthOffset;\n                   
      \n                            // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                            PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            void SetAttribute_44ECFDE2(inout
      float angleX, inout float angleY, inout float angleZ, float3 Angle) /*attribute:angle
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      angleX += Angle.x;\n                angleY += Angle.y;\n                angleZ
      += Angle.z;\n            }\n            \n            PackedVaryingsType ParticleVert(AttributesMesh
      inputMesh)\n            {\n                uint index = inputMesh.particleID;\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0x4) << 2));\n               
      float size = asfloat(attributeBuffer.Load((index * 0x4 + 0x7) << 2));\n               
      float angleX = asfloat(attributeBuffer.Load((index * 0x1 + 0x14) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (bool)true;\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             {\n                
      SetAttribute_C707D62A( /*inout */position, float3(0,8.33,0));\n            
      }\n             {\n                 SetAttribute_44ECFDE2( /*inout */angleX, 
      /*inout */angleY,  /*inout */angleZ, float3(-86.18,0,0));\n             }\n            
      \n                float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      #ifdef ATTRIBUTES_NEED_NORMAL\n                    float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                    inputMesh.normalOS.xyz
      = normalize(mul(elementToVFX,inputMesh.normalOS)) * normalFlip;\n               
      #endif\n                #ifdef ATTRIBUTES_NEED_TANGENT\n                   
      inputMesh.tangentOS.xyz = normalize(mul(elementToVFX,inputMesh.tangentOS));\n               
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  m_Infos:
    m_Expressions:
      m_Expressions:
      - op: 1
        valueIndex: 0
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 6
      - op: 1
        valueIndex: 1
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 2
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 5
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 8
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 11
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 7
      - op: 1
        valueIndex: 12
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 7
      - op: 1
        valueIndex: 13
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 16
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 7
      - op: 1
        valueIndex: 17
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 20
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 7
      - op: 1
        valueIndex: 21
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 7
      - op: 1
        valueIndex: 22
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 25
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 2
      - op: 1
        valueIndex: 27
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 30
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 31
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 15
      - op: 1
        valueIndex: 32
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 35
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 38
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 6
      - op: 1
        valueIndex: 39
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 15
      - op: 1
        valueIndex: 40
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 43
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      - op: 1
        valueIndex: 46
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 2
      - op: 1
        valueIndex: 48
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 7
      - op: 1
        valueIndex: 49
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 3
      m_NeedsLocalToWorld: 0
      m_NeedsWorldToLocal: 0
      m_NeededMainCameraBuffers: 0
    m_PropertySheet:
      m_Float:
        m_Array:
        - m_ExpressionIndex: 1
          m_Value: 23
        - m_ExpressionIndex: 15
          m_Value: 1.67
      m_Vector2f:
        m_Array:
        - m_ExpressionIndex: 13
          m_Value: {x: 2, y: 2}
        - m_ExpressionIndex: 23
          m_Value: {x: 0, y: 0}
      m_Vector3f:
        m_Array:
        - m_ExpressionIndex: 2
          m_Value: {x: 2, y: 0, z: 0}
        - m_ExpressionIndex: 3
          m_Value: {x: 5, y: 0, z: 0}
        - m_ExpressionIndex: 4
          m_Value: {x: 0, y: 5.26, z: 0}
        - m_ExpressionIndex: 7
          m_Value: {x: 0, y: 2.46, z: 0}
        - m_ExpressionIndex: 9
          m_Value: {x: 0, y: 5.18, z: 0}
        - m_ExpressionIndex: 12
          m_Value: {x: 0, y: 2.48, z: 0}
        - m_ExpressionIndex: 14
          m_Value: {x: 0, y: 8.33, z: 0}
        - m_ExpressionIndex: 17
          m_Value: {x: 9.121969, y: 9.943953, z: 2}
        - m_ExpressionIndex: 18
          m_Value: {x: 3.5609846, y: 4.4719763, z: 0}
        - m_ExpressionIndex: 21
          m_Value: {x: 2, y: 3, z: 2}
        - m_ExpressionIndex: 22
          m_Value: {x: 0, y: 1, z: 0}
        - m_ExpressionIndex: 25
          m_Value: {x: -86.18, y: 0, z: 0}
      m_Vector4f:
        m_Array: []
      m_Uint:
        m_Array:
        - m_ExpressionIndex: 0
          m_Value: 2
        - m_ExpressionIndex: 19
          m_Value: 4294967295
      m_Int:
        m_Array: []
      m_Matrix4x4f:
        m_Array: []
      m_AnimationCurve:
        m_Array: []
      m_Gradient:
        m_Array: []
      m_NamedObject:
        m_Array:
        - m_ExpressionIndex: 5
          m_Value: {fileID: 2800000, guid: 66e5bd50ca00dde428e8c4c63d8b903b, type: 3}
        - m_ExpressionIndex: 6
          m_Value: {fileID: 2800000, guid: 7a371224af202974e93f00c4f5a8eb38, type: 3}
        - m_ExpressionIndex: 8
          m_Value: {fileID: 2800000, guid: 3d9bb001b2ee8854b94910deb39fabc0, type: 3}
        - m_ExpressionIndex: 10
          m_Value: {fileID: 2800000, guid: 66e5bd50ca00dde428e8c4c63d8b903b, type: 3}
        - m_ExpressionIndex: 11
          m_Value: {fileID: 2800000, guid: 7a371224af202974e93f00c4f5a8eb38, type: 3}
        - m_ExpressionIndex: 24
          m_Value: {fileID: 2800000, guid: 3d9bb001b2ee8854b94910deb39fabc0, type: 3}
        - m_ExpressionIndex: 16
          m_Value: {fileID: 4300000, guid: 9e0af751bc36ea146940ba245193e28c, type: 3}
        - m_ExpressionIndex: 20
          m_Value: {fileID: 10208, guid: 0000000000000000e000000000000000, type: 0}
      m_Bool:
        m_Array: []
    m_ExposedExpressions: []
    m_Buffers:
    - type: 1
      size: 22
      layout:
      - name: particleId
        type: 6
        offset:
          bucket: 0
          structure: 1
          element: 0
      - name: position
        type: 3
        offset:
          bucket: 4
          structure: 4
          element: 0
      - name: size
        type: 1
        offset:
          bucket: 4
          structure: 4
          element: 3
      - name: angleX
        type: 1
        offset:
          bucket: 20
          structure: 1
          element: 0
      capacity: 2
      stride: 4
    - type: 1
      size: 22
      layout:
      - name: particleId
        type: 6
        offset:
          bucket: 0
          structure: 1
          element: 0
      - name: position
        type: 3
        offset:
          bucket: 4
          structure: 4
          element: 0
      - name: size
        type: 1
        offset:
          bucket: 4
          structure: 4
          element: 3
      - name: angleX
        type: 1
        offset:
          bucket: 20
          structure: 1
          element: 0
      capacity: 2
      stride: 4
    - type: 1
      size: 24
      layout:
      - name: particleId
        type: 6
        offset:
          bucket: 0
          structure: 1
          element: 0
      - name: position
        type: 3
        offset:
          bucket: 4
          structure: 4
          element: 0
      - name: size
        type: 1
        offset:
          bucket: 4
          structure: 4
          element: 3
      - name: angleX
        type: 1
        offset:
          bucket: 20
          structure: 1
          element: 0
      capacity: 4
      stride: 4
    - type: 1
      size: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      capacity: 1
      stride: 4
    - type: 1
      size: 24
      layout:
      - name: particleId
        type: 6
        offset:
          bucket: 0
          structure: 1
          element: 0
      - name: position
        type: 3
        offset:
          bucket: 4
          structure: 4
          element: 0
      - name: size
        type: 1
        offset:
          bucket: 4
          structure: 4
          element: 3
      - name: angleX
        type: 1
        offset:
          bucket: 20
          structure: 1
          element: 0
      capacity: 4
      stride: 4
    - type: 1
      size: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      capacity: 1
      stride: 4
    m_TemporaryBuffers: []
    m_CPUBuffers:
    - capacity: 1
      stride: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      initialData:
        data: 00000000
    - capacity: 1
      stride: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      initialData:
        data: 00000000
    - capacity: 1
      stride: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      initialData:
        data: 00000000
    m_Events:
    - name: OnPlay
      playSystems: 0000000001000000
      stopSystems: 
    - name: OnStop
      playSystems: 
      stopSystems: 0000000001000000
    m_RuntimeVersion: 10
    m_RendererSettings:
      motionVectorGenerationMode: 0
      shadowCastingMode: 0
      receiveShadows: 0
      reflectionProbeUsage: 0
      lightProbeUsage: 0
    m_CullingFlags: 3
    m_UpdateMode: 0
    m_PreWarmDeltaTime: 0.05
    m_PreWarmStepCount: 0
    m_InitialEventName: OnPlay
  m_Systems:
  - type: 0
    flags: 0
    capacity: 0
    layer: 4294967295
    buffers:
    - nameId: spawner_output
      index: 1
    values: []
    tasks:
    - type: 268435457
      buffers: []
      temporaryBuffers: []
      values:
      - nameId: Count
        index: 13
      - nameId: Delay
        index: 23
      params: []
      processor: {fileID: 0}
      shaderSourceIndex: -1
  - type: 0
    flags: 0
    capacity: 0
    layer: 4294967295
    buffers:
    - nameId: spawner_output
      index: 2
    values: []
    tasks:
    - type: 268435457
      buffers: []
      temporaryBuffers: []
      values:
      - nameId: Count
        index: 13
      - nameId: Delay
        index: 23
      params: []
      processor: {fileID: 0}
      shaderSourceIndex: -1
  - type: 1
    flags: 0
    capacity: 2
    layer: 4294967295
    buffers:
    - nameId: attributeBuffer
      index: 0
    - nameId: sourceAttributeBuffer
      index: 3
    - nameId: spawner_input
      index: 2
    values:
    - nameId: bounds_center
      index: 22
    - nameId: bounds_size
      index: 21
    tasks:
    - type: 536870912
      buffers:
      - nameId: attributeBuffer
        index: 0
      - nameId: sourceAttributeBuffer
        index: 3
      temporaryBuffers: []
      values: []
      params:
      - nameId: bounds_center
        index: 22
      - nameId: bounds_size
        index: 21
      processor: {fileID: 0}
      shaderSourceIndex: 0
    - type: 805306368
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values: []
      params: []
      processor: {fileID: 0}
      shaderSourceIndex: 1
    - type: 1073741826
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values:
      - nameId: _SampleTexture2D_1AFC26DB_Texture_1
        index: 24
      params:
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 2
    - type: 1073741826
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values:
      - nameId: _SampleTexture2D_21A3DC61_Texture_1
        index: 11
      - nameId: _SampleTexture2D_8E752C4E_Texture_1
        index: 10
      params:
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 3
    - type: 1073741828
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values: []
      params:
      - nameId: mesh
        index: 20
      - nameId: subMeshMask
        index: 19
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 4
    - type: 1073741828
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values: []
      params:
      - nameId: mesh
        index: 16
      - nameId: subMeshMask
        index: 19
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 10
  - type: 1
    flags: 0
    capacity: 2
    layer: 4294967295
    buffers:
    - nameId: attributeBuffer
      index: 1
    - nameId: sourceAttributeBuffer
      index: 5
    - nameId: spawner_input
      index: 1
    values:
    - nameId: bounds_center
      index: 18
    - nameId: bounds_size
      index: 17
    tasks:
    - type: 536870912
      buffers:
      - nameId: attributeBuffer
        index: 1
      - nameId: sourceAttributeBuffer
        index: 5
      temporaryBuffers: []
      values: []
      params:
      - nameId: bounds_center
        index: 18
      - nameId: bounds_size
        index: 17
      processor: {fileID: 0}
      shaderSourceIndex: 9
    - type: 805306368
      buffers:
      - nameId: attributeBuffer
        index: 1
      temporaryBuffers: []
      values: []
      params: []
      processor: {fileID: 0}
      shaderSourceIndex: 5
    - type: 1073741826
      buffers:
      - nameId: attributeBuffer
        index: 1
      temporaryBuffers: []
      values:
      - nameId: _SampleTexture2D_1AFC26DB_Texture_1
        index: 8
      params:
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 6
    - type: 1073741826
      buffers:
      - nameId: attributeBuffer
        index: 1
      temporaryBuffers: []
      values:
      - nameId: _SampleTexture2D_21A3DC61_Texture_1
        index: 6
      - nameId: _SampleTexture2D_8E752C4E_Texture_1
        index: 5
      params:
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 7
    - type: 1073741828
      buffers:
      - nameId: attributeBuffer
        index: 1
      temporaryBuffers: []
      values: []
      params:
      - nameId: mesh
        index: 20
      - nameId: subMeshMask
        index: 19
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 8
    - type: 1073741828
      buffers:
      - nameId: attributeBuffer
        index: 1
      temporaryBuffers: []
      values: []
      params:
      - nameId: mesh
        index: 16
      - nameId: subMeshMask
        index: 19
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 11
--- !u!114 &8926484042661614554
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a3006faa3d2c7044f9fd845cf4bf9333, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 310, y: 1107}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: 93fb7cf5b7d73ba4a8ea98879da717ef,
    type: 3}
  primitiveType: 1
--- !u!114 &8926484042661614556
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3ab9b05052599f344a6b1ae204834e10, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114946465509916290}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614557}
  - {fileID: 8926484042661614558}
  - {fileID: 8926484042661614559}
  - {fileID: 8926484042661614564}
  m_OutputSlots: []
  m_Disabled: 0
  shape: 0
  index: 0
  writePosition: 1
  writeTargetPosition: 0
  mode: 0
--- !u!114 &8926484042661614557
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4d246e354feb93041a837a9ef59437cb, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614557}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614556}
    m_Value:
      m_Type:
        m_SerializableType: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0
    m_Space: 2147483647
  m_Property:
    name: OffsetIndex
    m_serializedType:
      m_SerializableType: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Offset applied to the initial index used to compute the position
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614558
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614558}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614556}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 2
    m_Space: 2147483647
  m_Property:
    name: Count
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Element count used to loop over the sequence
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614559
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614560}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614559}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614556}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Start
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Start Position
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614560
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614559}
  m_Children:
  - {fileID: 8926484042661614561}
  - {fileID: 8926484042661614562}
  - {fileID: 8926484042661614563}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614559}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614561
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614560}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614559}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614562
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614560}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614559}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614563
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614560}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614559}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614564
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614565}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614564}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614556}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":2.0,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: End
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: End Position
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614565
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614564}
  m_Children:
  - {fileID: 8926484042661614566}
  - {fileID: 8926484042661614567}
  - {fileID: 8926484042661614568}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614564}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614566
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614565}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614564}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614567
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614565}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614564}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614568
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614565}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614564}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614569
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114946465509916290}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614570}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: size
  Composition: 0
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614570
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614570}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614569}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1.67
    m_Space: 2147483647
  m_Property:
    name: Size
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614571
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614571}
  m_MasterData:
    m_Owner: {fileID: 114131763552434164}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1
    m_Space: 2147483647
  m_Property:
    name: Lifetime
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614572
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5e382412bb691334bb79457a6c127924, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114023846229194376}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614573}
  - {fileID: 8926484042661614574}
  m_OutputSlots: []
  m_Disabled: 0
  repeat: 0
  spawnMode: 0
  delayMode: 0
--- !u!114 &8926484042661614573
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614573}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614572}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 2
    m_Space: 2147483647
  m_Property:
    name: Count
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Count for each burst
      m_Regex: 
      m_RegexMaxLength: 0
    - m_Type: 1
      m_Min: 0
      m_Max: Infinity
      m_Tooltip: 
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614574
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614574}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614572}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0
    m_Space: 2147483647
  m_Property:
    name: Delay
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Delay between each burst
      m_Regex: 
      m_RegexMaxLength: 0
    - m_Type: 1
      m_Min: 0
      m_Max: Infinity
      m_Tooltip: 
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614581
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114780028408030698}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614582}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: angle
  Composition: 0
  Source: 0
  Random: 0
  channels: 0
--- !u!114 &8926484042661614582
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614582}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614581}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 22.7
    m_Space: 2147483647
  m_Property:
    name: Angle
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots:
  - {fileID: 8926484042661614586}
--- !u!114 &8926484042661614583
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b8ee8a7543fa09e42a7c8616f60d2ad7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 496, y: 874}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614589}
  - {fileID: 8926484042661614585}
  m_OutputSlots:
  - {fileID: 8926484042661614586}
  m_Operands:
  - name: a
    type:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
  - name: b
    type:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
--- !u!114 &8926484042661614585
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614585}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614583}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 23
    m_Space: 2147483647
  m_Property:
    name: b
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614586
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614586}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614583}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: 
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 1
  m_LinkedSlots:
  - {fileID: 8926484042661614582}
--- !u!114 &8926484042661614587
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 486e063e1ed58c843942ea4122829ab1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 195, y: 877}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots:
  - {fileID: 8926484042661614588}
  attribute: particleId
  location: 0
  mask: xyz
--- !u!114 &8926484042661614588
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614588}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614587}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0
    m_Space: 2147483647
  m_Property:
    name: particleId
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 1
  m_LinkedSlots:
  - {fileID: 8926484042661614589}
--- !u!114 &8926484042661614589
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614589}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614583}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1
    m_Space: 2147483647
  m_Property:
    name: a
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots:
  - {fileID: 8926484042661614588}
--- !u!114 &8926484042661614593
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a3006faa3d2c7044f9fd845cf4bf9333, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614595}
  m_UIPosition: {x: 797, y: 1130}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: a2d673551d8a902418a20e89f0240eb4,
    type: 3}
  primitiveType: 1
--- !u!114 &8926484042661614595
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614593}
  m_Children: []
  m_UIPosition: {x: 0, y: 2}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614596}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614596
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614597}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614596}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614595}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":2.4800000190734865,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614597
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614596}
  m_Children:
  - {fileID: 8926484042661614598}
  - {fileID: 8926484042661614599}
  - {fileID: 8926484042661614600}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614596}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614598
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614597}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614596}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614599
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614597}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614596}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614600
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614597}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614596}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614601
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f4476dfd621f4fe428fe6e72d10aa015, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614605}
  m_UIPosition: {x: 1280, y: 1096}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614602}
  - {fileID: 8926484042661614603}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: 8a868d2e86b59114da19cee76949d9aa,
    type: 3}
--- !u!114 &8926484042661614602
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b47b8679b468b7347a00cdd50589bc9f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614602}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614601}
    m_Value:
      m_Type:
        m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
          Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"obj":{"fileID":10208,"guid":"0000000000000000e000000000000000","type":0}}'
    m_Space: 2147483647
  m_Property:
    name: mesh
    m_serializedType:
      m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Mesh to be used for particle rendering.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614603
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614603}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614601}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 4294967295
    m_Space: 2147483647
  m_Property:
    name: subMeshMask
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Define a bitmask to control which submeshes are rendered.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614605
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614601}
  m_Children: []
  m_UIPosition: {x: 0, y: 2}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614606}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614606
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614607}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614605}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":5.179999828338623,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614607
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614606}
  m_Children:
  - {fileID: 8926484042661614608}
  - {fileID: 8926484042661614609}
  - {fileID: 8926484042661614610}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614608
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614607}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614609
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614607}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614610
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614607}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614611
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 73a13919d81fb7444849bae8b5c812a2, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614612}
  m_UIPosition: {x: 2149, y: -172}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 0}
  m_InputFlowSlot:
  - link: []
  - link: []
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614639}
      slotIndex: 0
--- !u!114 &8926484042661614612
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5e382412bb691334bb79457a6c127924, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614611}
  m_Children: []
  m_UIPosition: {x: 128.16296, y: 75.2439}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614613}
  - {fileID: 8926484042661614614}
  m_OutputSlots: []
  m_Disabled: 0
  repeat: 0
  spawnMode: 0
  delayMode: 0
--- !u!114 &8926484042661614613
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614613}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614612}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 2
    m_Space: 2147483647
  m_Property:
    name: Count
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Count for each burst
      m_Regex: 
      m_RegexMaxLength: 0
    - m_Type: 1
      m_Min: 0
      m_Max: Infinity
      m_Tooltip: 
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614614
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614614}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614612}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0
    m_Space: 2147483647
  m_Property:
    name: Delay
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Delay between each burst
      m_Regex: 
      m_RegexMaxLength: 0
    - m_Type: 1
      m_Min: 0
      m_Max: Infinity
      m_Tooltip: 
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614615
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2dc095764ededfa4bb32fa602511ea4b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614617}
  m_UIPosition: {x: 2156, y: 804}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 8926484042661614649}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614639}
      slotIndex: 0
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614719}
      slotIndex: 0
    - context: {fileID: 8926484042661614621}
      slotIndex: 0
    - context: {fileID: 8926484042661614629}
      slotIndex: 0
    - context: {fileID: 8926484042661614695}
      slotIndex: 0
  integration: 0
  angularIntegration: 0
  ageParticles: 1
  reapParticles: 1
--- !u!114 &8926484042661614617
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614615}
  m_Children: []
  m_UIPosition: {x: 128.16296, y: 75.2439}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614618}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: angle
  Composition: 0
  Source: 0
  Random: 0
  channels: 0
--- !u!114 &8926484042661614618
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614618}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614617}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 22.7
    m_Space: 2147483647
  m_Property:
    name: Angle
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots:
  - {fileID: 8926484042661614672}
--- !u!114 &8926484042661614621
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a3006faa3d2c7044f9fd845cf4bf9333, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614623}
  m_UIPosition: {x: 2643, y: 1106}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 8926484042661614649}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614615}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: 8047542b6592261479680e73a59b2c0c,
    type: 3}
  primitiveType: 1
--- !u!114 &8926484042661614623
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614621}
  m_Children: []
  m_UIPosition: {x: 128.16296, y: 75.2439}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614624}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614624
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614625}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614624}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614623}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":2.4600000381469728,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614625
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614624}
  m_Children:
  - {fileID: 8926484042661614626}
  - {fileID: 8926484042661614627}
  - {fileID: 8926484042661614628}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614624}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614626
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614625}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614624}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614627
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614625}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614624}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614628
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614625}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614624}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614629
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f4476dfd621f4fe428fe6e72d10aa015, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614633}
  m_UIPosition: {x: 3126, y: 1072}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614630}
  - {fileID: 8926484042661614631}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 8926484042661614649}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614615}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: 4f88789362ae4f045872a34ceb75f117,
    type: 3}
--- !u!114 &8926484042661614630
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b47b8679b468b7347a00cdd50589bc9f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614630}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614629}
    m_Value:
      m_Type:
        m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
          Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"obj":{"fileID":10208,"guid":"0000000000000000e000000000000000","type":0}}'
    m_Space: 2147483647
  m_Property:
    name: mesh
    m_serializedType:
      m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Mesh to be used for particle rendering.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614631
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614631}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614629}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 4294967295
    m_Space: 2147483647
  m_Property:
    name: subMeshMask
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Define a bitmask to control which submeshes are rendered.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614633
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614629}
  m_Children: []
  m_UIPosition: {x: 128.16296, y: 75.2439}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614634}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614634
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614635}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614634}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614633}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":5.260000228881836,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614635
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614634}
  m_Children:
  - {fileID: 8926484042661614636}
  - {fileID: 8926484042661614637}
  - {fileID: 8926484042661614638}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614634}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614636
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614635}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614634}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614637
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614635}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614634}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614638
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614635}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614634}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614639
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 9dfea48843f53fc438eabc12a3a30abc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614650}
  - {fileID: 8926484042661614652}
  - {fileID: 8926484042661614665}
  - {fileID: 8926484042661614673}
  m_UIPosition: {x: 2155, y: 131}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614640}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 8926484042661614649}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614611}
      slotIndex: 0
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614615}
      slotIndex: 0
--- !u!114 &8926484042661614640
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 1b605c022ee79394a8a776c0869b3f9a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614641}
  - {fileID: 8926484042661614645}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614639}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.AABox, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"center":{"x":3.5609846115112306,"y":4.471976280212402,"z":0.0},"size":{"x":9.121969223022461,"y":9.943952560424805,"z":2.0}}'
    m_Space: 0
  m_Property:
    name: bounds
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.AABox, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614641
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614640}
  m_Children:
  - {fileID: 8926484042661614642}
  - {fileID: 8926484042661614643}
  - {fileID: 8926484042661614644}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: center
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The centre of the box.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614642
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614641}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614643
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614641}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614644
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614641}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614645
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614640}
  m_Children:
  - {fileID: 8926484042661614646}
  - {fileID: 8926484042661614647}
  - {fileID: 8926484042661614648}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: size
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The size of the box along each axis.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614646
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614645}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614647
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614645}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614648
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614645}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614640}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614649
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d78581a96eae8bf4398c282eb0b098bd, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  title: 
  m_Owners:
  - {fileID: 8926484042661614639}
  - {fileID: 8926484042661614615}
  - {fileID: 8926484042661614719}
  - {fileID: 8926484042661614621}
  - {fileID: 8926484042661614629}
  - {fileID: 8926484042661614695}
  m_Capacity: 2
  m_Space: 0
--- !u!114 &8926484042661614650
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614639}
  m_Children: []
  m_UIPosition: {x: 128.16296, y: 75.2439}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614651}
  m_OutputSlots: []
  m_Disabled: 1
  attribute: lifetime
  Composition: 0
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614651
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614651}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614650}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1
    m_Space: 2147483647
  m_Property:
    name: Lifetime
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614652
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3ab9b05052599f344a6b1ae204834e10, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614639}
  m_Children: []
  m_UIPosition: {x: 128.16296, y: 75.2439}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614653}
  - {fileID: 8926484042661614654}
  - {fileID: 8926484042661614655}
  - {fileID: 8926484042661614660}
  m_OutputSlots: []
  m_Disabled: 0
  shape: 0
  index: 0
  writePosition: 1
  writeTargetPosition: 0
  mode: 0
--- !u!114 &8926484042661614653
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4d246e354feb93041a837a9ef59437cb, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614653}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614652}
    m_Value:
      m_Type:
        m_SerializableType: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0
    m_Space: 2147483647
  m_Property:
    name: OffsetIndex
    m_serializedType:
      m_SerializableType: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Offset applied to the initial index used to compute the position
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614654
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614654}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614652}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 2
    m_Space: 2147483647
  m_Property:
    name: Count
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Element count used to loop over the sequence
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614655
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614656}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614655}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614652}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Start
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Start Position
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614656
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614655}
  m_Children:
  - {fileID: 8926484042661614657}
  - {fileID: 8926484042661614658}
  - {fileID: 8926484042661614659}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614655}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614657
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614656}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614655}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614658
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614656}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614655}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614659
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614656}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614655}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614660
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614661}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614660}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614652}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":2.0,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: End
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: End Position
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614661
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614660}
  m_Children:
  - {fileID: 8926484042661614662}
  - {fileID: 8926484042661614663}
  - {fileID: 8926484042661614664}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614660}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614662
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614661}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614660}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614663
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614661}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614660}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614664
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614661}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614660}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614665
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614639}
  m_Children: []
  m_UIPosition: {x: 128.16296, y: 75.2439}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614666}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: size
  Composition: 0
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614666
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614666}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614665}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1.67
    m_Space: 2147483647
  m_Property:
    name: Size
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614667
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 486e063e1ed58c843942ea4122829ab1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 1642, y: 830}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots:
  - {fileID: 8926484042661614668}
  attribute: particleId
  location: 0
  mask: xyz
--- !u!114 &8926484042661614668
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614668}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614667}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0
    m_Space: 2147483647
  m_Property:
    name: particleId
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 1
  m_LinkedSlots:
  - {fileID: 8926484042661614670}
--- !u!114 &8926484042661614669
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b8ee8a7543fa09e42a7c8616f60d2ad7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 1943, y: 827}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614670}
  - {fileID: 8926484042661614671}
  m_OutputSlots:
  - {fileID: 8926484042661614672}
  m_Operands:
  - name: a
    type:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
  - name: b
    type:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
--- !u!114 &8926484042661614670
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614670}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614669}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1
    m_Space: 2147483647
  m_Property:
    name: a
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots:
  - {fileID: 8926484042661614668}
--- !u!114 &8926484042661614671
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614671}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614669}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 23
    m_Space: 2147483647
  m_Property:
    name: b
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614672
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614672}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614669}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: 
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 1
  m_LinkedSlots:
  - {fileID: 8926484042661614618}
--- !u!114 &8926484042661614673
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614639}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614674}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614674
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614675}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614674}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614673}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":5.0,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614675
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614674}
  m_Children:
  - {fileID: 8926484042661614676}
  - {fileID: 8926484042661614677}
  - {fileID: 8926484042661614678}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614674}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614676
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614675}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614674}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614677
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614675}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614674}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614678
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614675}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614674}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614680
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f4476dfd621f4fe428fe6e72d10aa015, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614684}
  - {fileID: 8926484042661614690}
  m_UIPosition: {x: 1682, y: 1100}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614681}
  - {fileID: 8926484042661614682}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: 92bd7f65f47a3fc4ba445ac285842615,
    type: 3}
--- !u!114 &8926484042661614681
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b47b8679b468b7347a00cdd50589bc9f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614681}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614680}
    m_Value:
      m_Type:
        m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
          Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"obj":{"fileID":4300000,"guid":"9e0af751bc36ea146940ba245193e28c","type":3}}'
    m_Space: 2147483647
  m_Property:
    name: mesh
    m_serializedType:
      m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Mesh to be used for particle rendering.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614682
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614682}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614680}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 4294967295
    m_Space: 2147483647
  m_Property:
    name: subMeshMask
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Define a bitmask to control which submeshes are rendered.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614684
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614680}
  m_Children: []
  m_UIPosition: {x: 0, y: 2}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614685}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614685
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614686}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614685}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614684}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":8.329999923706055,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614686
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614685}
  m_Children:
  - {fileID: 8926484042661614687}
  - {fileID: 8926484042661614688}
  - {fileID: 8926484042661614689}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614685}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614687
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614686}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614685}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614688
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614686}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614685}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614689
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614686}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614685}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614690
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614680}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614691}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: angle
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614691
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614692}
  - {fileID: 8926484042661614693}
  - {fileID: 8926484042661614694}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614691}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614690}
    m_Value:
      m_Type:
        m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
          Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"x":-86.18000030517578,"y":0.0,"z":0.0}'
    m_Space: 2147483647
  m_Property:
    name: Angle
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614692
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614691}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614691}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614693
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614691}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614691}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614694
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614691}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614691}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614695
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f4476dfd621f4fe428fe6e72d10aa015, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614699}
  - {fileID: 8926484042661614705}
  m_UIPosition: {x: 3552, y: 1069}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614696}
  - {fileID: 8926484042661614697}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 8926484042661614649}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614615}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: c3810538f1ea0f849819352ace5e2214,
    type: 3}
--- !u!114 &8926484042661614696
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b47b8679b468b7347a00cdd50589bc9f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614696}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614695}
    m_Value:
      m_Type:
        m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
          Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"obj":{"fileID":4300000,"guid":"9e0af751bc36ea146940ba245193e28c","type":3}}'
    m_Space: 2147483647
  m_Property:
    name: mesh
    m_serializedType:
      m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Mesh to be used for particle rendering.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614697
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614697}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614695}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 4294967295
    m_Space: 2147483647
  m_Property:
    name: subMeshMask
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Define a bitmask to control which submeshes are rendered.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614699
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614695}
  m_Children: []
  m_UIPosition: {x: 854.07715, y: -220.73169}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614700}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614700
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614701}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614700}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614699}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":8.329999923706055,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614701
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614700}
  m_Children:
  - {fileID: 8926484042661614702}
  - {fileID: 8926484042661614703}
  - {fileID: 8926484042661614704}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614700}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614702
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614701}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614700}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614703
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614701}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614700}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614704
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614701}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614700}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614705
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614695}
  m_Children: []
  m_UIPosition: {x: 854.07715, y: -222.73169}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614706}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: angle
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614706
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614707}
  - {fileID: 8926484042661614708}
  - {fileID: 8926484042661614709}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614706}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614705}
    m_Value:
      m_Type:
        m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
          Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"x":-86.18000030517578,"y":0.0,"z":0.0}'
    m_Space: 2147483647
  m_Property:
    name: Angle
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614707
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614706}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614706}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614708
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614706}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614706}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614709
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614706}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614706}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614719
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a3006faa3d2c7044f9fd845cf4bf9333, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 2156, y: 1083}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 8926484042661614649}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614615}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: 66f03bbc88cdc684aabef5ff92b4d8c5,
    type: 3}
  primitiveType: 1
