%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &114023846229194376
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 73a13919d81fb7444849bae8b5c812a2, type: 3}
  m_Name: VFXBasicSpawner
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 114873264888500148}
  m_UIPosition: {x: 959, y: -154}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 0}
  m_InputFlowSlot:
  - link: []
  - link: []
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 114946465509916290}
      slotIndex: 0
--- !u!114 &114131763552434164
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: SetAttribute
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114946465509916290}
  m_Children: []
  m_UIPosition: {x: 0, y: 93}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614551}
  - {fileID: 8926484042661614552}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: lifetime
  Composition: 0
  Source: 0
  Random: 2
  channels: 6
--- !u!114 &114206037049139666
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: SetAttribute
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114946465509916290}
  m_Children: []
  m_UIPosition: {x: 0, y: 2}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614541}
  - {fileID: 8926484042661614546}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: velocity
  Composition: 0
  Source: 0
  Random: 1
  channels: 6
--- !u!114 &114307113894698210
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 1b605c022ee79394a8a776c0869b3f9a, type: 3}
  m_Name: VFXSlot
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 114986932069951040}
  - {fileID: 114963171269329408}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 114946465509916290}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.AABox, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"center":{"x":0.0,"y":1.0,"z":0.0},"size":{"x":2.0,"y":3.0,"z":2.0}}'
    m_Space: 0
  m_Property:
    name: bounds
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.AABox, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114340500867371532
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d01270efd3285ea4a9d6c555cb0a8027, type: 3}
  m_Name: VFXUI
  m_EditorClassIdentifier: 
  groupInfos: []
  stickyNoteInfos: []
  systemInfos: []
  categories: []
  uiBounds:
    serializedVersion: 2
    x: 363
    y: -154
    width: 1580
    height: 1240
--- !u!114 &114350483966674976
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7d4c867f6b72b714dbb5fd1780afe208, type: 3}
  m_Name: HDRPUnlit
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 114023846229194376}
  - {fileID: 114946465509916290}
  - {fileID: 114780028408030698}
  - {fileID: 8926484042661614554}
  - {fileID: 8926484042661614566}
  - {fileID: 8926484042661614578}
  - {fileID: 8926484042661614611}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_UIInfos: {fileID: 114340500867371532}
  m_ParameterInfo: []
  m_GraphVersion: 2
  m_saved: 1
  m_SubgraphDependencies: []
  m_CategoryPath: 
--- !u!114 &114380859405582094
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114963171269329408}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114428730288789306
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d78581a96eae8bf4398c282eb0b098bd, type: 3}
  m_Name: VFXDataParticle
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  title: 
  m_Owners:
  - {fileID: 114946465509916290}
  - {fileID: 114780028408030698}
  - {fileID: 8926484042661614554}
  - {fileID: 8926484042661614566}
  - {fileID: 8926484042661614578}
  - {fileID: 8926484042661614611}
  m_Capacity: 32
  m_Space: 0
--- !u!114 &114512514798047786
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114963171269329408}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114538391275492396
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114986932069951040}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114571176826476282
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114571176826476282}
  m_MasterData:
    m_Owner: {fileID: 114873264888500148}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 10
    m_Space: 2147483647
  m_Property:
    name: Rate
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 1
      m_Min: 0
      m_Max: Infinity
      m_Tooltip: 
      m_Regex: 
      m_RegexMaxLength: 0
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Spawn Rate (in number per seconds)
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114739294351936256
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114986932069951040}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114780028408030698
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2dc095764ededfa4bb32fa602511ea4b, type: 3}
  m_Name: VFXBasicUpdate
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children: []
  m_UIPosition: {x: 955, y: 620}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots: []
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114946465509916290}
      slotIndex: 0
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 8926484042661614554}
      slotIndex: 0
    - context: {fileID: 8926484042661614566}
      slotIndex: 0
    - context: {fileID: 8926484042661614578}
      slotIndex: 0
    - context: {fileID: 8926484042661614611}
      slotIndex: 0
  integration: 0
  angularIntegration: 0
  ageParticles: 1
  reapParticles: 1
--- !u!114 &114873264888500148
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f05c6884b705ce14d82ae720f0ec209f, type: 3}
  m_Name: VFXSpawnerConstantRate
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114023846229194376}
  m_Children: []
  m_UIPosition: {x: 0, y: 2}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 114571176826476282}
  m_OutputSlots: []
  m_Disabled: 0
--- !u!114 &114920711487922656
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114963171269329408}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114935892456706286
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: VFXSlotFloat
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114986932069951040}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114946465509916290
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 9dfea48843f53fc438eabc12a3a30abc, type: 3}
  m_Name: VFXBasicInitialize
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 114206037049139666}
  - {fileID: 114131763552434164}
  - {fileID: 8926484042661614603}
  - {fileID: 8926484042661614605}
  m_UIPosition: {x: 959, y: 93}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 114307113894698210}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114023846229194376}
      slotIndex: 0
  m_OutputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
--- !u!114 &114963171269329408
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: VFXSlotFloat3
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114307113894698210}
  m_Children:
  - {fileID: 114512514798047786}
  - {fileID: 114920711487922656}
  - {fileID: 114380859405582094}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: size
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The size of the box along each axis.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &114986932069951040
MonoBehaviour:
  m_ObjectHideFlags: 1
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: VFXSlotFloat3
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114307113894698210}
  m_Children:
  - {fileID: 114739294351936256}
  - {fileID: 114935892456706286}
  - {fileID: 114538391275492396}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 114307113894698210}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: center
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The centre of the box.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!2058629511 &8926484042661614527
VisualEffectResource:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: HDRPUnlit
  m_Graph: {fileID: 114350483966674976}
  m_ShaderSources:
  - compute: 1
    name: '[System 1]Initialize'
    source: "#pragma kernel CSMain\n#define NB_THREADS_PER_GROUP 64\n#define VFX_USE_VELOCITY_CURRENT
      1\n#define VFX_USE_SEED_CURRENT 1\n#define VFX_USE_LIFETIME_CURRENT 1\n#define
      VFX_USE_SIZE_CURRENT 1\n#define VFX_USE_POSITION_CURRENT 1\n#define VFX_USE_ALIVE_CURRENT
      1\n#define VFX_USE_AGE_CURRENT 1\n#define VFX_LOCAL_SPACE 1\n#include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n\n\nCBUFFER_START(parameters)\n   
      float3 A_a;\n    float A_b;\n    float3 B_a;\n    float B_b;\n    float3 Position_d;\n   
      float Size_c;\nCBUFFER_END\n\n\n#include \"Packages/com.unity.visualeffectgraph/Shaders/Common/VFXCommonCompute.cginc\"\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n\n\n\nRWByteAddressBuffer
      attributeBuffer;\nByteAddressBuffer sourceAttributeBuffer;\n\nCBUFFER_START(initParams)\n#if
      !VFX_USE_SPAWNER_FROM_GPU\n    uint nbSpawned;\t\t\t\t\t// Numbers of particle
      spawned\n    uint spawnIndex;\t\t\t\t// Index of the first particle spawned\n   
      uint dispatchWidth;\n#else\n    uint offsetInAdditionalOutput;\n\tuint nbMax;\n#endif\n\tuint
      systemSeed;\nCBUFFER_END\n\n#if VFX_USE_ALIVE_CURRENT\nRWStructuredBuffer<uint>
      deadListIn;\nByteAddressBuffer deadListCount; // This is bad to use a SRV to
      fetch deadList count but Unity API currently prevent from copying to CB\n#endif\n\n#if
      VFX_USE_SPAWNER_FROM_GPU\nStructuredBuffer<uint> eventList;\nByteAddressBuffer
      inputAdditional;\n#endif\n\nvoid SetAttribute_E6295C0(inout float3 velocity,
      inout uint seed, float3 A, float3 B) /*attribute:velocity Composition:Overwrite
      Source:Slot Random:PerComponent channels:XYZ */\n{\n    velocity = lerp(A,B,RAND3);\n}\nvoid
      SetAttribute_F01429A3(inout float lifetime, inout uint seed, float A, float
      B) /*attribute:lifetime Composition:Overwrite Source:Slot Random:Uniform channels:XYZ
      */\n{\n    lifetime = lerp(A,B,RAND);\n}\nvoid SetAttribute_3278B22F(inout
      float size, float Size) /*attribute:size Composition:Overwrite Source:Slot
      Random:Off channels:XYZ */\n{\n    size = Size;\n}\nvoid SetAttribute_CAC29747(inout
      float3 position, float3 Position) /*attribute:position Composition:Overwrite
      Source:Slot Random:Off channels:XYZ */\n{\n    position = Position;\n}\n\n\n\n[numthreads(NB_THREADS_PER_GROUP,1,1)]\nvoid
      CSMain(uint3 groupId          : SV_GroupID,\n            uint3 groupThreadId   
      : SV_GroupThreadID)\n{\n    uint id = groupThreadId.x + groupId.x * NB_THREADS_PER_GROUP;\n#if
      !VFX_USE_SPAWNER_FROM_GPU\n    id += groupId.y * dispatchWidth * NB_THREADS_PER_GROUP;\n#endif\n\n#if
      VFX_USE_SPAWNER_FROM_GPU\n    uint maxThreadId = inputAdditional.Load((offsetInAdditionalOutput
      * 2 + 0) << 2);\n    uint currentSpawnIndex = inputAdditional.Load((offsetInAdditionalOutput
      * 2 + 1) << 2) - maxThreadId;\n#else\n    uint maxThreadId = nbSpawned;\n   
      uint currentSpawnIndex = spawnIndex;\n#endif\n\n#if VFX_USE_ALIVE_CURRENT\n   
      maxThreadId = min(maxThreadId, deadListCount.Load(0x0));\n#elif VFX_USE_SPAWNER_FROM_GPU\n   
      maxThreadId = min(maxThreadId, nbMax); //otherwise, nbSpawned already clamped
      on CPU\n#endif\n\n    if (id < maxThreadId)\n    {\n#if VFX_USE_SPAWNER_FROM_GPU\n       
      int sourceIndex = eventList[id];\n#endif\n        uint particleIndex = id +
      currentSpawnIndex;\n\t\t\n#if !VFX_USE_SPAWNER_FROM_GPU\n        int sourceIndex
      = 0;\n        /*//Loop with 1 iteration generate a wrong IL Assembly (and actually,
      useless code)\n        uint currentSumSpawnCount = 0u;\n        for (sourceIndex=0;
      sourceIndex<1; sourceIndex++)\n        {\n            currentSumSpawnCount
      += uint(asfloat(sourceAttributeBuffer.Load((sourceIndex * 0x1 + 0x0) << 2)));\n           
      if (id < currentSumSpawnCount)\n            {\n                break;\n           
      }\n        }\n        */\n        \n\n#endif\n        float3 velocity = float3(0,0,0);\n       
      uint seed = (uint)0;\n        float lifetime = (float)1;\n        float size
      = (float)0.1;\n        float3 position = float3(0,0,0);\n        bool alive
      = (bool)true;\n        float age = (float)0;\n        \n\n#if VFX_USE_PARTICLEID_CURRENT\n        
      particleId = particleIndex;\n#endif\n#if VFX_USE_SEED_CURRENT\n        seed
      = WangHash(particleIndex ^ systemSeed);\n#endif\n        \n        SetAttribute_E6295C0(
      /*inout */velocity,  /*inout */seed, A_a, B_a);\n        SetAttribute_F01429A3(
      /*inout */lifetime,  /*inout */seed, A_b, B_b);\n        SetAttribute_3278B22F(
      /*inout */size, Size_c);\n        SetAttribute_CAC29747( /*inout */position,
      Position_d);\n        \n\n\n#if VFX_USE_ALIVE_CURRENT\n        if (alive)\n       
      {\n\t\t\tuint deadIndex = deadListIn.DecrementCounter();\n            uint
      index = deadListIn[deadIndex];\n            attributeBuffer.Store3((index *
      0x4 + 0x0) << 2,asuint(velocity));\n            attributeBuffer.Store((index
      * 0x4 + 0x3) << 2,asuint(lifetime));\n            attributeBuffer.Store((index
      * 0x1 + 0x80) << 2,asuint(size));\n            attributeBuffer.Store3((index
      * 0x4 + 0xA0) << 2,asuint(position));\n            attributeBuffer.Store((index
      * 0x4 + 0xA3) << 2,uint(alive));\n            attributeBuffer.Store((index
      * 0x1 + 0x120) << 2,asuint(age));\n            \n\n        }\n#else\n       
      uint index = particleIndex;\n        attributeBuffer.Store3((index * 0x4 +
      0x0) << 2,asuint(velocity));\n        attributeBuffer.Store((index * 0x4 +
      0x3) << 2,asuint(lifetime));\n        attributeBuffer.Store((index * 0x1 +
      0x80) << 2,asuint(size));\n        attributeBuffer.Store3((index * 0x4 + 0xA0)
      << 2,asuint(position));\n        attributeBuffer.Store((index * 0x4 + 0xA3)
      << 2,uint(alive));\n        attributeBuffer.Store((index * 0x1 + 0x120) <<
      2,asuint(age));\n        \n\n#endif\n    }\n}\n"
  - compute: 1
    name: '[System 1]Update'
    source: "#pragma kernel CSMain\n#define NB_THREADS_PER_GROUP 64\n#define VFX_USE_VELOCITY_CURRENT
      1\n#define VFX_USE_LIFETIME_CURRENT 1\n#define VFX_USE_POSITION_CURRENT 1\n#define
      VFX_USE_ALIVE_CURRENT 1\n#define VFX_USE_AGE_CURRENT 1\n#define VFX_LOCAL_SPACE
      1\n#include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n\n\nCBUFFER_START(parameters)\n   
      float deltaTime_a;\n    uint3 PADDING_0;\nCBUFFER_END\n\n\n#include \"Packages/com.unity.visualeffectgraph/Shaders/Common/VFXCommonCompute.cginc\"\n#include
      \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n\n\n\nRWByteAddressBuffer
      attributeBuffer;\n\n#if VFX_USE_ALIVE_CURRENT\nRWStructuredBuffer<uint> deadListOut;\n#endif\n\n#if
      VFX_HAS_INDIRECT_DRAW\nRWStructuredBuffer<uint> indirectBuffer;\n#endif\n\nCBUFFER_START(updateParams)\n   
      uint nbMax;\n\tuint dispatchWidth;\n\tuint systemSeed;\nCBUFFER_END\n\nvoid
      EulerIntegration(inout float3 position, float3 velocity, float deltaTime)\n{\n   
      position += velocity * deltaTime;\n}\nvoid Age(inout float age, float deltaTime)\n{\n   
      age += deltaTime;\n}\nvoid Reap(float age, float lifetime, inout bool alive)\n{\n   
      if(age > lifetime) { alive = false; }\n}\n\n\n\n[numthreads(NB_THREADS_PER_GROUP,1,1)]\nvoid
      CSMain(uint3 groupId          : SV_GroupID,\n            uint3 groupThreadId   
      : SV_GroupThreadID)\n{\n\tuint id = groupThreadId.x + groupId.x * NB_THREADS_PER_GROUP
      + groupId.y * dispatchWidth * NB_THREADS_PER_GROUP;\n\tuint index = id;\n\tif
      (id < nbMax)\n\t{\n#if VFX_USE_ALIVE_CURRENT\n\t\tbool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n\t\t\n\n\t\tif (alive)\n\t\t{\n\t\t\tfloat3 velocity
      = asfloat(attributeBuffer.Load3((index * 0x4 + 0x0) << 2));\n\t\t\tfloat lifetime
      = asfloat(attributeBuffer.Load((index * 0x4 + 0x3) << 2));\n\t\t\tfloat3 position
      = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n\t\t\tfloat age
      = asfloat(attributeBuffer.Load((index * 0x1 + 0x120) << 2));\n\t\t\t\n\n\t\t\t\n#if
      VFX_USE_OLDPOSITION_CURRENT\n\t\t\toldPosition = position;\n#endif\n\t\t\t\n\t\t\tEulerIntegration(
      /*inout */position, velocity, deltaTime_a);\n\t\t\tAge( /*inout */age, deltaTime_a);\n\t\t\tReap(age,
      lifetime,  /*inout */alive);\n\t\t\t\n\n\t\t\tif (alive)\n\t\t\t{\n\t\t\t\tattributeBuffer.Store3((index
      * 0x4 + 0xA0) << 2,asuint(position));\n\t\t\t\tattributeBuffer.Store((index
      * 0x1 + 0x120) << 2,asuint(age));\n\t\t\t\t\n\n#if VFX_HAS_INDIRECT_DRAW\n               
      uint indirectIndex = indirectBuffer.IncrementCounter();\n\t\t\t\tindirectBuffer[indirectIndex]
      = index;\n#endif\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tattributeBuffer.Store((index
      * 0x4 + 0xA3) << 2,uint(alive));\n\t\t\t\t\n\n\t\t\t\tuint deadIndex = deadListOut.IncrementCounter();\n\t\t\t\tdeadListOut[deadIndex]
      = index;\n\t\t\t}\n\t\t}\n#else\n\t\tfloat3 velocity = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0x0) << 2));\n\t\tfloat lifetime = asfloat(attributeBuffer.Load((index
      * 0x4 + 0x3) << 2));\n\t\tfloat3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n\t\tbool alive = (attributeBuffer.Load((index * 0x4
      + 0xA3) << 2));\n\t\tfloat age = asfloat(attributeBuffer.Load((index * 0x1
      + 0x120) << 2));\n\t\t\n\n\t\t\n#if VFX_USE_OLDPOSITION_CURRENT\n\t\toldPosition
      = position;\n#endif\n\t\t\n\t\tEulerIntegration( /*inout */position, velocity,
      deltaTime_a);\n\t\tAge( /*inout */age, deltaTime_a);\n\t\tReap(age, lifetime, 
      /*inout */alive);\n\t\t\n\n\t\tattributeBuffer.Store3((index * 0x4 + 0xA0)
      << 2,asuint(position));\n\t\tattributeBuffer.Store((index * 0x4 + 0xA3) <<
      2,uint(alive));\n\t\tattributeBuffer.Store((index * 0x1 + 0x120) << 2,asuint(age));\n\t\t\n\n#if
      VFX_HAS_INDIRECT_DRAW\n        uint indirectIndex = indirectBuffer.IncrementCounter();\n\t\tindirectBuffer[indirectIndex]
      = index;\n#endif\n#endif\n\t}\n}\n"
  - compute: 0
    name: '[System 1]A Shader Graph Quad Output'
    source: "Shader \"Hidden/VFX/HDRPUnlit/System 1/(A) Shader Graph Quad Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDUnlitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 0\n            Stencil\n            {\n               
      WriteMask 48\n                Ref 0\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 1\n            Stencil\n            {\n               
      WriteMask 176\n                Ref 128\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                           
      //   FragInputs.positionRWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ForwardOnly\"\n           
      Tags {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n           
      ZTest [_ZTestTransparent]\n            ZWrite On\n            Blend One Zero,
      One Zero\n            Stencil\n            {\n                WriteMask 3\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD_UNLIT\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForwardUnlit.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 2) + instID * 2048;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n               
      float2 uv;\n                uv.x = float(id & 1);\n             uv.y = float((id
      & 2) >> 1);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n             inputMesh.uv0.xy
      = uv;\n            #endif\n                inputMesh.positionOS = float3(uv
      - 0.5f,0);\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 1]B Shader Graph Triangle Output'
    source: "Shader \"Hidden/VFX/HDRPUnlit/System 1/(B) Shader Graph Triangle Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDUnlitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID)\n            {\n             uint particleID
      = id / 3;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n             const float2 kOffsets[] = {\n             
      float2(-0.5f,  -0.288675129413604736328125f),\n              float2(0.0f, 
      0.57735025882720947265625f),\n              float2(0.5f, -0.288675129413604736328125f),\n            
      };\n             \n             const float kUVScale = 0.866025388240814208984375f;\n\n               
      inputMesh.positionOS = float3(kOffsets[id % 3],0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = (inputMesh.positionOS.xy * kUVScale) + 0.5f;\n           
      #endif\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID)\n            {\n             uint particleID
      = id / 3;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n             const float2 kOffsets[] = {\n             
      float2(-0.5f,  -0.288675129413604736328125f),\n              float2(0.0f, 
      0.57735025882720947265625f),\n              float2(0.5f, -0.288675129413604736328125f),\n            
      };\n             \n             const float kUVScale = 0.866025388240814208984375f;\n\n               
      inputMesh.positionOS = float3(kOffsets[id % 3],0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = (inputMesh.positionOS.xy * kUVScale) + 0.5f;\n           
      #endif\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID)\n            {\n             uint particleID
      = id / 3;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n             const float2 kOffsets[] = {\n             
      float2(-0.5f,  -0.288675129413604736328125f),\n              float2(0.0f, 
      0.57735025882720947265625f),\n              float2(0.5f, -0.288675129413604736328125f),\n            
      };\n             \n             const float kUVScale = 0.866025388240814208984375f;\n\n               
      inputMesh.positionOS = float3(kOffsets[id % 3],0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = (inputMesh.positionOS.xy * kUVScale) + 0.5f;\n           
      #endif\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 0\n            Stencil\n            {\n               
      WriteMask 48\n                Ref 0\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID)\n            {\n             uint particleID
      = id / 3;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n             const float2 kOffsets[] = {\n             
      float2(-0.5f,  -0.288675129413604736328125f),\n              float2(0.0f, 
      0.57735025882720947265625f),\n              float2(0.5f, -0.288675129413604736328125f),\n            
      };\n             \n             const float kUVScale = 0.866025388240814208984375f;\n\n               
      inputMesh.positionOS = float3(kOffsets[id % 3],0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = (inputMesh.positionOS.xy * kUVScale) + 0.5f;\n           
      #endif\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 1\n            Stencil\n            {\n               
      WriteMask 176\n                Ref 128\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                           
      //   FragInputs.positionRWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID)\n            {\n             uint particleID
      = id / 3;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n             const float2 kOffsets[] = {\n             
      float2(-0.5f,  -0.288675129413604736328125f),\n              float2(0.0f, 
      0.57735025882720947265625f),\n              float2(0.5f, -0.288675129413604736328125f),\n            
      };\n             \n             const float kUVScale = 0.866025388240814208984375f;\n\n               
      inputMesh.positionOS = float3(kOffsets[id % 3],0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = (inputMesh.positionOS.xy * kUVScale) + 0.5f;\n           
      #endif\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ForwardOnly\"\n           
      Tags {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n           
      ZTest [_ZTestTransparent]\n            ZWrite On\n            Blend One Zero,
      One Zero\n            Stencil\n            {\n                WriteMask 3\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD_UNLIT\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForwardUnlit.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID)\n            {\n             uint particleID
      = id / 3;\n                uint index = particleID;\n                AttributesMesh
      inputMesh = (AttributesMesh)0;\n             const float2 kOffsets[] = {\n             
      float2(-0.5f,  -0.288675129413604736328125f),\n              float2(0.0f, 
      0.57735025882720947265625f),\n              float2(0.5f, -0.288675129413604736328125f),\n            
      };\n             \n             const float kUVScale = 0.866025388240814208984375f;\n\n               
      inputMesh.positionOS = float3(kOffsets[id % 3],0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = (inputMesh.positionOS.xy * kUVScale) + 0.5f;\n           
      #endif\n                inputMesh.particleID = particleID;\n               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n               
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n               
      float3 color = float3(1,1,1);\n                float alpha = (float)1;\n               
      bool alive = (attributeBuffer.Load((index * 0x4 + 0xA3) << 2));\n               
      float3 axisX = float3(1,0,0);\n                float3 axisY = float3(0,1,0);\n               
      float3 axisZ = float3(0,0,1);\n                float angleX = (float)0;\n               
      float angleY = (float)0;\n                float angleZ = (float)0;\n               
      float pivotX = (float)0;\n                float pivotY = (float)0;\n               
      float pivotZ = (float)0;\n                float scaleX = (float)1;\n               
      float scaleY = (float)1;\n                float scaleZ = (float)1;\n               
      \n                float3 size3 = float3(size,size,size);\n                #if
      VFX_USE_SCALEX_CURRENT\n                size3.x *= scaleX;\n               
      #endif\n                #if VFX_USE_SCALEY_CURRENT\n                size3.y
      *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 1]C Shader Graph Octagon Output'
    source: "Shader \"Hidden/VFX/HDRPUnlit/System 1/(C) Shader Graph Octagon Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDUnlitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                float cropFactor;\n               
      uint2 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 3) + instID * 1024;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n            
      const float2 kUvs[8] = \n             {\n              float2(-0.5f, 0.0f),\n             
      float2(-0.5f, 0.5f),\n              float2(0.0f, 0.5f),\n              float2(0.5f,
      0.5f),\n              float2(0.5f, 0.0f),\n              float2(0.5f, -0.5f),\n             
      float2(0.0f, -0.5f),\n              float2(-0.5f, -0.5f),\n             };\n\n            
      \n\n             float cf = id & 1 ? 1.0f - cropFactor : 1.0f;\n               
      inputMesh.positionOS =  float3(kUvs[id & 7]  * cf,0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = inputMesh.positionOS.xy + 0.5f;\n            #endif\n               
      inputMesh.particleID = particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                float cropFactor;\n               
      uint2 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 3) + instID * 1024;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n            
      const float2 kUvs[8] = \n             {\n              float2(-0.5f, 0.0f),\n             
      float2(-0.5f, 0.5f),\n              float2(0.0f, 0.5f),\n              float2(0.5f,
      0.5f),\n              float2(0.5f, 0.0f),\n              float2(0.5f, -0.5f),\n             
      float2(0.0f, -0.5f),\n              float2(-0.5f, -0.5f),\n             };\n\n            
      \n\n             float cf = id & 1 ? 1.0f - cropFactor : 1.0f;\n               
      inputMesh.positionOS =  float3(kUvs[id & 7]  * cf,0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = inputMesh.positionOS.xy + 0.5f;\n            #endif\n               
      inputMesh.particleID = particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                float cropFactor;\n               
      uint2 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 3) + instID * 1024;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n            
      const float2 kUvs[8] = \n             {\n              float2(-0.5f, 0.0f),\n             
      float2(-0.5f, 0.5f),\n              float2(0.0f, 0.5f),\n              float2(0.5f,
      0.5f),\n              float2(0.5f, 0.0f),\n              float2(0.5f, -0.5f),\n             
      float2(0.0f, -0.5f),\n              float2(-0.5f, -0.5f),\n             };\n\n            
      \n\n             float cf = id & 1 ? 1.0f - cropFactor : 1.0f;\n               
      inputMesh.positionOS =  float3(kUvs[id & 7]  * cf,0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = inputMesh.positionOS.xy + 0.5f;\n            #endif\n               
      inputMesh.particleID = particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 0\n            Stencil\n            {\n               
      WriteMask 48\n                Ref 0\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                float cropFactor;\n               
      uint2 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 3) + instID * 1024;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n            
      const float2 kUvs[8] = \n             {\n              float2(-0.5f, 0.0f),\n             
      float2(-0.5f, 0.5f),\n              float2(0.0f, 0.5f),\n              float2(0.5f,
      0.5f),\n              float2(0.5f, 0.0f),\n              float2(0.5f, -0.5f),\n             
      float2(0.0f, -0.5f),\n              float2(-0.5f, -0.5f),\n             };\n\n            
      \n\n             float cf = id & 1 ? 1.0f - cropFactor : 1.0f;\n               
      inputMesh.positionOS =  float3(kUvs[id & 7]  * cf,0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = inputMesh.positionOS.xy + 0.5f;\n            #endif\n               
      inputMesh.particleID = particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 1\n            Stencil\n            {\n               
      WriteMask 176\n                Ref 128\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                           
      //   FragInputs.positionRWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                float cropFactor;\n               
      uint2 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 3) + instID * 1024;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n            
      const float2 kUvs[8] = \n             {\n              float2(-0.5f, 0.0f),\n             
      float2(-0.5f, 0.5f),\n              float2(0.0f, 0.5f),\n              float2(0.5f,
      0.5f),\n              float2(0.5f, 0.0f),\n              float2(0.5f, -0.5f),\n             
      float2(0.0f, -0.5f),\n              float2(-0.5f, -0.5f),\n             };\n\n            
      \n\n             float cf = id & 1 ? 1.0f - cropFactor : 1.0f;\n               
      inputMesh.positionOS =  float3(kUvs[id & 7]  * cf,0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = inputMesh.positionOS.xy + 0.5f;\n            #endif\n               
      inputMesh.particleID = particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n        Pass\n        {\n            name \"ForwardOnly\"\n           
      Tags {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n           
      ZTest [_ZTestTransparent]\n            ZWrite On\n            Blend One Zero,
      One Zero\n            Stencil\n            {\n                WriteMask 3\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD_UNLIT\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                float cropFactor;\n               
      uint2 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForwardUnlit.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(uint id : SV_VertexID,uint instID : SV_InstanceID)\n           
      {\n             uint particleID = (id >> 3) + instID * 1024;\n               
      uint index = particleID;\n                AttributesMesh inputMesh = (AttributesMesh)0;\n            
      const float2 kUvs[8] = \n             {\n              float2(-0.5f, 0.0f),\n             
      float2(-0.5f, 0.5f),\n              float2(0.0f, 0.5f),\n              float2(0.5f,
      0.5f),\n              float2(0.5f, 0.0f),\n              float2(0.5f, -0.5f),\n             
      float2(0.0f, -0.5f),\n              float2(-0.5f, -0.5f),\n             };\n\n            
      \n\n             float cf = id & 1 ? 1.0f - cropFactor : 1.0f;\n               
      inputMesh.positionOS =  float3(kUvs[id & 7]  * cf,0);\n            #ifdef ATTRIBUTES_NEED_TEXCOORD0\n            
      inputMesh.uv0.xy = inputMesh.positionOS.xy + 0.5f;\n            #endif\n               
      inputMesh.particleID = particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n           
      #ifdef ATTRIBUTES_NEED_NORMAL\n                float normalFlip = (size3.x
      * size3.y * size3.z) < 0 ? -1 : 1;\n                inputMesh.normalOS.xyz
      = normalize(-transpose(elementToVFX)[2].xyz) * normalFlip;\n            #endif\n           
      #ifdef ATTRIBUTES_NEED_TANGENT\n                inputMesh.tangentOS.xyz = normalize(transpose(elementToVFX)[0].xyz);\n           
      #endif\n            \n\n                float3 objectPos = inputMesh.positionOS;\n               
      float3 particlePos = mul(elementToVFX,float4(objectPos,1)).xyz;\n               
      inputMesh.positionOS = particlePos;\n                PackedVaryingsType result
      = Vert(inputMesh);\n\n                result.vmesh.particleID = inputMesh.particleID;
      // transmit the instanceID to the pixel shader through the varyings\n               
      return result;\n            }\n            #pragma vertex ParticleVert\n\n           
      ENDHLSL\n        }\n    }\n        }\n"
  - compute: 0
    name: '[System 1]D Shader Graph Mesh Output'
    source: "Shader \"Hidden/VFX/HDRPUnlit/System 1/(D) Shader Graph Mesh Output\"\n{\n   
      HLSLINCLUDE\n    #define UNITY_VFX_ACTIVE 1\n    #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXDefines.hlsl\"\n   
      ENDHLSL\n    SubShader\n    {\n        Tags {\"RenderPipeline\" = \"HDRenderPipeline\"
      \"RenderType\" = \"HDUnlitShader\" \"Queue\" = \"Geometry+0\" }\n        Pass\n       
      {\n            name \"META\"\n            Tags {\"LightMode\" = \"META\" }\n           
      Cull Off\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   AttributesMesh.normalOS\n                           
      //   AttributesMesh.tangentOS\n                            //   AttributesMesh.uv0\n                           
      //   AttributesMesh.uv1\n                            //   AttributesMesh.color\n                           
      //   AttributesMesh.uv2\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      #define ATTRIBUTES_NEED_NORMAL\n                        #define ATTRIBUTES_NEED_TANGENT\n                       
      #define ATTRIBUTES_NEED_TEXCOORD0\n                        #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      float3 normalOS : NORMAL; // optional\n                        float4 tangentOS
      : TANGENT; // optional\n                        float4 uv0 : TEXCOORD0; //
      optional\n                        float4 uv1 : TEXCOORD1; // optional\n                       
      float4 uv2 : TEXCOORD2; // optional\n                        float4 color :
      COLOR; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      float3 objectPos = inputMesh.positionOS;\n                float3 particlePos
      = mul(elementToVFX,float4(objectPos,1)).xyz;\n                inputMesh.positionOS
      = particlePos;\n                PackedVaryingsType result = Vert(inputMesh);\n\n               
      result.vmesh.particleID = inputMesh.particleID; // transmit the instanceID
      to the pixel shader through the varyings\n                return result;\n           
      }\n            #pragma vertex ParticleVert\n\n            ENDHLSL\n       
      }\n        Pass\n        {\n            name \"ShadowCaster\"\n           
      Tags {\"LightMode\" = \"ShadowCaster\" }\n            Cull Back\n           
      ZWrite On\n            ZClip [_ZClip]\n            ColorMask 0\n           
      HLSLPROGRAM\n\n            struct ParticleMeshToPS\n            {\n\n           
      };\n            \n                    \n                        #pragma target
      4.5\n                        #pragma only_renderers d3d11 ps4 xboxone vulkan
      metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_SHADOWS\n                            // ACTIVE
      FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      float3 objectPos = inputMesh.positionOS;\n                float3 particlePos
      = mul(elementToVFX,float4(objectPos,1)).xyz;\n                inputMesh.positionOS
      = particlePos;\n                PackedVaryingsType result = Vert(inputMesh);\n\n               
      result.vmesh.particleID = inputMesh.particleID; // transmit the instanceID
      to the pixel shader through the varyings\n                return result;\n           
      }\n            #pragma vertex ParticleVert\n\n            ENDHLSL\n       
      }\n        Pass\n        {\n            name \"SceneSelectionPass\"\n           
      Tags {\"LightMode\" = \"SceneSelectionPass\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0\n            HLSLPROGRAM\n\n           
      struct ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #define
      SCENESELECTIONPASS\n                            #pragma editor_sync_compilation\n                           
      // ACTIVE FIELDS:\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      // #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      float3 objectPos = inputMesh.positionOS;\n                float3 particlePos
      = mul(elementToVFX,float4(objectPos,1)).xyz;\n                inputMesh.positionOS
      = particlePos;\n                PackedVaryingsType result = Vert(inputMesh);\n\n               
      result.vmesh.particleID = inputMesh.particleID; // transmit the instanceID
      to the pixel shader through the varyings\n                return result;\n           
      }\n            #pragma vertex ParticleVert\n\n            ENDHLSL\n       
      }\n        Pass\n        {\n            name \"DepthForwardOnly\"\n           
      Tags {\"LightMode\" = \"DepthForwardOnly\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 0\n            Stencil\n            {\n               
      WriteMask 48\n                Ref 0\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        // #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float4 positionCS
      : SV_Position; // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        output.instanceID
      = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            // output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      float3 objectPos = inputMesh.positionOS;\n                float3 particlePos
      = mul(elementToVFX,float4(objectPos,1)).xyz;\n                inputMesh.positionOS
      = particlePos;\n                PackedVaryingsType result = Vert(inputMesh);\n\n               
      result.vmesh.particleID = inputMesh.particleID; // transmit the instanceID
      to the pixel shader through the varyings\n                return result;\n           
      }\n            #pragma vertex ParticleVert\n\n            ENDHLSL\n       
      }\n        Pass\n        {\n            name \"MotionVectors\"\n           
      Tags {\"LightMode\" = \"MotionVectors\" }\n            Cull Back\n           
      ZWrite On\n            ColorMask 0 1\n            Stencil\n            {\n               
      WriteMask 176\n                Ref 128\n                Comp Always\n               
      Pass Replace\n            }\n            HLSLPROGRAM\n\n            struct
      ParticleMeshToPS\n            {\n\n            };\n            \n                   
      \n                        #pragma target 4.5\n                        #pragma
      only_renderers d3d11 ps4 xboxone vulkan metal switch\n                       
      //#pragma enable_d3d11_debug_symbols\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_MOTION_VECTORS\n                            #pragma
      multi_compile _ WRITE_MSAA_DEPTH\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescription.Alpha\n                            //   SurfaceDescription.AlphaClipThreshold\n                           
      //   FragInputs.positionRWS\n                            //   VaryingsMeshToPS.positionRWS\n                           
      //   AttributesMesh.positionOS\n                    \n                       
      // this translates the new dependency tracker into the old preprocessor definitions
      for the existing HDRP shader code\n                        // #define ATTRIBUTES_NEED_NORMAL\n                       
      // #define ATTRIBUTES_NEED_TANGENT\n                        // #define ATTRIBUTES_NEED_TEXCOORD0\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD1\n                        // #define ATTRIBUTES_NEED_TEXCOORD2\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD3\n                        // #define ATTRIBUTES_NEED_COLOR\n                       
      #define VARYINGS_NEED_POSITION_WS\n                        // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                       
      // #define VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    #if
      UNITY_VFX_ACTIVE\n                                    uint particleID;\n                                   
      #endif // UNITY_VFX_ACTIVE\n                                };\n                           
      // Pixel Graph Outputs\n                                struct SurfaceDescription\n                               
      {\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                };\n                               
      \n                            // Shared Graph Node Functions\n            ByteAddressBuffer
      attributeBuffer;\n            SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs
      IN,ParticleMeshToPS vParticle)\n                                {\n                                               
      uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    surface.Alpha
      = 1;\n                                    surface.AlphaClipThreshold = 0.5;\n                                   
      surface.Alpha *= alpha;\n                                    return surface;\n                               
      }\n                            // Pixel Graph Evaluation\n                               
      \n                        //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      // output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            // surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      // builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      float3 objectPos = inputMesh.positionOS;\n                float3 particlePos
      = mul(elementToVFX,float4(objectPos,1)).xyz;\n                inputMesh.positionOS
      = particlePos;\n                PackedVaryingsType result = Vert(inputMesh);\n\n               
      result.vmesh.particleID = inputMesh.particleID; // transmit the instanceID
      to the pixel shader through the varyings\n                return result;\n           
      }\n            #pragma vertex ParticleVert\n\n            ENDHLSL\n       
      }\n        Pass\n        {\n            name \"ForwardOnly\"\n            Tags
      {\"LightMode\" = \"ForwardOnly\" }\n            Cull Back\n            ZTest
      [_ZTestTransparent]\n            ZWrite On\n            Blend One Zero, One
      Zero\n            Stencil\n            {\n                WriteMask 3\n               
      Ref 2\n                Comp Always\n                Pass Replace\n           
      }\n            HLSLPROGRAM\n\n            struct ParticleMeshToPS\n           
      {\n\n            };\n            \n                    \n                       
      #pragma target 4.5\n                        #pragma only_renderers d3d11 ps4
      xboxone vulkan metal switch\n                        //#pragma enable_d3d11_debug_symbols\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Variant\n                        //-------------------------------------------------------------------------------------\n                       
      \n                        // #pragma shader_feature_local _DOUBLESIDED_ON -
      We have no lighting, so no need to have this combination for shader, the option
      will just disable backface culling\n                    \n                       
      // Keyword for transparent\n                        #pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n                        #pragma shader_feature_local
      _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n                   
      \n                        // #define _ENABLE_FOG_ON_TRANSPARENT 1\n                   
      \n                        //enable GPU instancing support\n                       
      #pragma multi_compile_instancing\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Variant Definitions\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        #pragma fragment Frag\n                    \n                       
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Defines\n                        //-------------------------------------------------------------------------------------\n                               
      #define SHADERPASS SHADERPASS_FORWARD_UNLIT\n                            #pragma
      multi_compile _ DEBUG_DISPLAY\n                            // ACTIVE FIELDS:\n                           
      //   SurfaceDescriptionInputs.ObjectSpacePosition\n                           
      //   SurfaceDescription.Color\n                            //   SurfaceDescription.Alpha\n                           
      //   SurfaceDescription.AlphaClipThreshold\n                            //  
      SurfaceDescription.Emission\n                            //   FragInputs.positionRWS\n                           
      //   VaryingsMeshToPS.positionRWS\n                            //   AttributesMesh.positionOS\n                   
      \n                        // this translates the new dependency tracker into
      the old preprocessor definitions for the existing HDRP shader code\n                       
      // #define ATTRIBUTES_NEED_NORMAL\n                        // #define ATTRIBUTES_NEED_TANGENT\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD0\n                        // #define ATTRIBUTES_NEED_TEXCOORD1\n                       
      // #define ATTRIBUTES_NEED_TEXCOORD2\n                        // #define ATTRIBUTES_NEED_TEXCOORD3\n                       
      // #define ATTRIBUTES_NEED_COLOR\n                        #define VARYINGS_NEED_POSITION_WS\n                       
      // #define VARYINGS_NEED_TANGENT_TO_WORLD\n                        // #define
      VARYINGS_NEED_TEXCOORD0\n                        // #define VARYINGS_NEED_TEXCOORD1\n                       
      // #define VARYINGS_NEED_TEXCOORD2\n                        // #define VARYINGS_NEED_TEXCOORD3\n                       
      // #define VARYINGS_NEED_COLOR\n                        // #define VARYINGS_NEED_CULLFACE\n                       
      // #define HAVE_MESH_MODIFICATION\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Defines\n                        //-------------------------------------------------------------------------------------\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Unlit/Unlit.hlsl\"\n                   
      \n                        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n                       
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n                   
      \n                        // Used by SceneSelectionPass\n                       
      int _ObjectId;\n                        int _PassValue;\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Interpolator Packing And Struct Declarations\n                        //-------------------------------------------------------------------------------------\n                   
      // Generated Type: AttributesMesh\n                    struct AttributesMesh
      {\n                        float3 positionOS : POSITION;\n                       
      #if UNITY_ANY_INSTANCING_ENABLED\n                        uint instanceID :
      INSTANCEID_SEMANTIC;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : SV_InstanceID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                    };\n                    \n                   
      // Generated Type: VaryingsMeshToPS\n                    struct VaryingsMeshToPS
      {\n                        float4 positionCS : SV_Position;\n                       
      float3 positionRWS; // optional\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        uint particleID : CUSTOM_INSTANCE_ID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                    };\n                   
      struct PackedVaryingsMeshToPS {\n                        float3 interp00 :
      TEXCOORD0; // auto-packed\n                        float4 positionCS : SV_Position;
      // unpacked\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                        #if UNITY_VFX_ACTIVE\n                       
      uint particleID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        FRONT_FACE_TYPE
      cullFace : FRONT_FACE_SEMANTIC; // unpacked\n                        #endif
      // defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n                   
      };\n                    PackedVaryingsMeshToPS PackVaryingsMeshToPS(VaryingsMeshToPS
      input)\n                    {\n                        PackedVaryingsMeshToPS
      output;\n                        output.positionCS = input.positionCS;\n                       
      output.interp00.xyz = input.positionRWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    VaryingsMeshToPS UnpackVaryingsMeshToPS(PackedVaryingsMeshToPS
      input)\n                    {\n                        VaryingsMeshToPS output;\n                       
      output.positionCS = input.positionCS;\n                        output.positionRWS
      = input.interp00.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      #if UNITY_VFX_ACTIVE\n                        output.particleID = input.particleID;\n                       
      #endif // UNITY_VFX_ACTIVE\n                        #if defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        output.cullFace
      = input.cullFace;\n                        #endif // defined(SHADER_STAGE_FRAGMENT)
      && defined(VARYINGS_NEED_CULLFACE)\n                        return output;\n                   
      }\n                    \n                    // Generated Type: VaryingsMeshToDS\n                   
      struct VaryingsMeshToDS {\n                        float3 positionRWS;\n                       
      float3 normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                   
      };\n                    struct PackedVaryingsMeshToDS {\n                       
      float3 interp00 : TEXCOORD0; // auto-packed\n                        float3
      interp01 : TEXCOORD1; // auto-packed\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      uint instanceID : CUSTOM_INSTANCE_ID; // unpacked\n                       
      #endif // UNITY_ANY_INSTANCING_ENABLED\n                    };\n                   
      PackedVaryingsMeshToDS PackVaryingsMeshToDS(VaryingsMeshToDS input)\n                   
      {\n                        PackedVaryingsMeshToDS output;\n                       
      output.interp00.xyz = input.positionRWS;\n                        output.interp01.xyz
      = input.normalWS;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    VaryingsMeshToDS
      UnpackVaryingsMeshToDS(PackedVaryingsMeshToDS input)\n                    {\n                       
      VaryingsMeshToDS output;\n                        output.positionRWS = input.interp00.xyz;\n                       
      output.normalWS = input.interp01.xyz;\n                        #if UNITY_ANY_INSTANCING_ENABLED\n                       
      output.instanceID = input.instanceID;\n                        #endif // UNITY_ANY_INSTANCING_ENABLED\n                       
      return output;\n                    }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Interpolator Packing And Struct Declarations\n                       
      //-------------------------------------------------------------------------------------\n                   
      \n                        //-------------------------------------------------------------------------------------\n                       
      // Graph generated code\n                        //-------------------------------------------------------------------------------------\n                               
      // Shared Graph Properties (uniform inputs)\n            CBUFFER_START(parameters)\n               
      float3 Position_a;\n                float Vector1_4B24F63;\n               
      float Vector1_9B1964B1;\n                uint3 PADDING_0;\n            CBUFFER_END\n\n                               
      struct SurfaceDescriptionInputs {\n                                    float3
      ObjectSpacePosition; // optional\n                                    #if UNITY_VFX_ACTIVE\n                                   
      uint particleID;\n                                    #endif // UNITY_VFX_ACTIVE\n                               
      };\n                            // Pixel Graph Outputs\n                               
      struct SurfaceDescription\n                                {\n                                   
      float3 Color;\n                                    float Alpha;\n                                   
      float AlphaClipThreshold;\n                                    float3 Emission;\n                               
      };\n                                \n                            // Shared
      Graph Node Functions\n                            \n                               
      void Unity_InverseLerp_float(float A, float B, float T, out float Out)\n                               
      {\n                                    Out = (T - A)/(B - A);\n                               
      }\n                            \n                                void Unity_SampleGradient_float(Gradient
      Gradient, float Time, out float4 Out)\n                                {\n                                   
      float3 color = Gradient.colors[0].rgb;\n                                   
      [unroll]\n                                    for (int c = 1; c < 8; c++)\n                                   
      {\n                                        float colorPos = saturate((Time
      - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w))
      * step(c, Gradient.colorsLength-1);\n                                       
      color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos),
      Gradient.type));\n                                    }\n                               
      #ifndef UNITY_COLORSPACE_GAMMA\n                                    color =
      SRGBToLinear(color);\n                                #endif\n                                   
      float alpha = Gradient.alphas[0].x;\n                                    [unroll]\n                                   
      for (int a = 1; a < 8; a++)\n                                    {\n                                       
      float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y
      - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1);\n                                       
      alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos),
      Gradient.type));\n                                    }\n                                   
      Out = float4(color, alpha);\n                                }\n                           
      \n            ByteAddressBuffer attributeBuffer;\n            SurfaceDescription
      SurfaceDescriptionFunction(SurfaceDescriptionInputs IN,ParticleMeshToPS vParticle)\n                               
      {\n                                                uint index = IN.particleID;\n                                               
      float size = asfloat(attributeBuffer.Load((index * 0x1 + 0x80) << 2));\n                                   
      float3 position = asfloat(attributeBuffer.Load3((index * 0x4 + 0xA0) << 2));\n                                   
      float3 color = float3(1,1,1);\n                                    float alpha
      = (float)1;\n                                    bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                                    float3 axisX = float3(1,0,0);\n                                   
      float3 axisY = float3(0,1,0);\n                                    float3 axisZ
      = float3(0,0,1);\n                                    float angleX = (float)0;\n                                   
      float angleY = (float)0;\n                                    float angleZ
      = (float)0;\n                                    float pivotX = (float)0;\n                                   
      float pivotY = (float)0;\n                                    float pivotZ
      = (float)0;\n                                    float scaleX = (float)1;\n                                   
      float scaleY = (float)1;\n                                    float scaleZ
      = (float)1;\n                                    \n            \n\n    if(
      !alive) discard;\n    \n                                    SurfaceDescription
      surface = (SurfaceDescription)0;\n                                    Gradient
      _Gradient_98BB5E59_Out_0 = NewGradient(0, 7, 2, float4(0.8469865, 1, 0.0990566,
      0),float4(0.7294118, 0.08530336, 0.07058822, 0.1819791),float4(0.4582389, 0.04705882,
      0.4941176, 0.3604791),float4(0.02995378, 0.02745097, 0.2745098, 0.5303273),float4(0.1229052,
      0.4049238, 0.6743622, 0.6967117),float4(0.3398006, 0.8679245, 0.393839, 0.8370947),float4(0.8470588,
      1, 0.09803922, 0.9947967),float4(0, 0, 0, 0), float2(1, 0),float2(1, 1),float2(0,
      0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0),float2(0, 0));\n                                   
      float _Property_7B40AA1C_Out_0 = Vector1_4B24F63;\n                                   
      float _Property_85C76B20_Out_0 = Vector1_9B1964B1;\n                                   
      float _Split_3B890ED_R_1 = IN.ObjectSpacePosition[0];\n                                   
      float _Split_3B890ED_G_2 = IN.ObjectSpacePosition[1];\n                                   
      float _Split_3B890ED_B_3 = IN.ObjectSpacePosition[2];\n                                   
      float _Split_3B890ED_A_4 = 0;\n                                    float _InverseLerp_10C65378_Out_3;\n                                   
      Unity_InverseLerp_float(_Property_7B40AA1C_Out_0, _Property_85C76B20_Out_0,
      _Split_3B890ED_R_1, _InverseLerp_10C65378_Out_3);\n                                   
      float4 _SampleGradient_3305CB8E_Out_2;\n                                   
      Unity_SampleGradient_float(_Gradient_98BB5E59_Out_0, _InverseLerp_10C65378_Out_3,
      _SampleGradient_3305CB8E_Out_2);\n                                    surface.Color
      = (_SampleGradient_3305CB8E_Out_2.xyz);\n                                   
      surface.Alpha = 1;\n                                    surface.AlphaClipThreshold
      = 0.5;\n                                    surface.Emission = float3(0, 0,
      0);\n                                    surface.Alpha *= alpha;\n                                   
      return surface;\n                                }\n                           
      // Pixel Graph Evaluation\n                                \n                       
      //-------------------------------------------------------------------------------------\n                       
      // End graph generated code\n                        //-------------------------------------------------------------------------------------\n                   
      \n                    // $include(\"VertexAnimation.template.hlsl\")\n                   
      \n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                       
      FragInputs BuildFragInputs(VaryingsMeshToPS input)\n                       
      {\n                            FragInputs output;\n                           
      ZERO_INITIALIZE(FragInputs, output);\n                    \n                           
      // Init to some default value to make the computer quiet (else it output 'divide
      by zero' warning even if value is not used).\n                            //
      TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                            // to compute normals which are then
      passed on elsewhere to compute other values...\n                           
      output.tangentToWorld = k_identity3x3;\n                            output.positionSS
      = input.positionCS;       // input.positionCS is SV_Position\n                   
      \n                            output.positionRWS = input.positionRWS;\n                           
      // output.tangentToWorld = BuildTangentToWorld(input.tangentWS, input.normalWS);\n                           
      // output.texCoord0 = input.texCoord0;\n                            // output.texCoord1
      = input.texCoord1;\n                            // output.texCoord2 = input.texCoord2;\n                           
      // output.texCoord3 = input.texCoord3;\n                            // output.color
      = input.color;\n                            #if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                           
      output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #elif SHADER_STAGE_FRAGMENT\n                            // output.isFrontFace
      = IS_FRONT_VFACE(input.cullFace, true, false);\n                           
      #endif // SHADER_STAGE_FRAGMENT\n                    \n                           
      return output;\n                        }\n                    \n                       
      SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input,
      float3 viewWS)\n                        {\n                            SurfaceDescriptionInputs
      output;\n                            ZERO_INITIALIZE(SurfaceDescriptionInputs,
      output);\n                    \n                            // output.WorldSpaceNormal
      =            normalize(input.tangentToWorld[2].xyz);\n                           
      // output.ObjectSpaceNormal =           mul(output.WorldSpaceNormal, (float3x3)
      UNITY_MATRIX_M);           // transposed multiplication by inverse matrix to
      handle normal scale\n                            // output.ViewSpaceNormal
      =             mul(output.WorldSpaceNormal, (float3x3) UNITY_MATRIX_I_V);        
      // transposed multiplication by inverse matrix to handle normal scale\n                           
      // output.TangentSpaceNormal =          float3(0.0f, 0.0f, 1.0f);\n                           
      // output.WorldSpaceTangent =           input.tangentToWorld[0].xyz;\n                           
      // output.ObjectSpaceTangent =          TransformWorldToObjectDir(output.WorldSpaceTangent);\n                           
      // output.ViewSpaceTangent =            TransformWorldToViewDir(output.WorldSpaceTangent);\n                           
      // output.TangentSpaceTangent =         float3(1.0f, 0.0f, 0.0f);\n                           
      // output.WorldSpaceBiTangent =         input.tangentToWorld[1].xyz;\n                           
      // output.ObjectSpaceBiTangent =        TransformWorldToObjectDir(output.WorldSpaceBiTangent);\n                           
      // output.ViewSpaceBiTangent =          TransformWorldToViewDir(output.WorldSpaceBiTangent);\n                           
      // output.TangentSpaceBiTangent =       float3(0.0f, 1.0f, 0.0f);\n                           
      // output.WorldSpaceViewDirection =     normalize(viewWS);\n                           
      // output.ObjectSpaceViewDirection =    TransformWorldToObjectDir(output.WorldSpaceViewDirection);\n                           
      // output.ViewSpaceViewDirection =      TransformWorldToViewDir(output.WorldSpaceViewDirection);\n                           
      // float3x3 tangentSpaceTransform =     float3x3(output.WorldSpaceTangent,output.WorldSpaceBiTangent,output.WorldSpaceNormal);\n                           
      // output.TangentSpaceViewDirection =   mul(tangentSpaceTransform, output.WorldSpaceViewDirection);\n                           
      // output.WorldSpacePosition =          input.positionRWS;\n                           
      output.ObjectSpacePosition =         TransformWorldToObject(input.positionRWS);\n                           
      // output.ViewSpacePosition =           TransformWorldToView(input.positionRWS);\n                           
      // output.TangentSpacePosition =        float3(0.0f, 0.0f, 0.0f);\n                           
      // output.AbsoluteWorldSpacePosition =  GetAbsolutePositionWS(input.positionRWS);\n                           
      // output.ScreenPosition =              ComputeScreenPos(TransformWorldToHClip(input.positionRWS),
      _ProjectionParams.x);\n                            // output.uv0 =                        
      input.texCoord0;\n                            // output.uv1 =                        
      input.texCoord1;\n                            // output.uv2 =                        
      input.texCoord2;\n                            // output.uv3 =                        
      input.texCoord3;\n                            // output.VertexColor =                
      input.color;\n                            // output.FaceSign =                   
      input.isFrontFace;\n                            // output.TimeParameters =             
      _TimeParameters.xyz; // This is mainly for LW as HD overwrite this value\n                   
      \n                            output.particleID = input.particleID;\n                           
      return output;\n                        }\n                    \n                       
      // existing HDRP code uses the combined function to go directly from packed
      to frag inputs\n                        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS
      input)\n                        {\n                            UNITY_SETUP_INSTANCE_ID(input);\n                           
      VaryingsMeshToPS unpacked= UnpackVaryingsMeshToPS(input);\n                           
      FragInputs fragInputs = BuildFragInputs(unpacked);\n                    #ifdef
      UNITY_VFX_ACTIVE\n                            fragInputs.particleID = input.particleID;\n                   
      #endif\n                            return fragInputs;\n                       
      }\n                    \n                    //-------------------------------------------------------------------------------------\n                   
      // END TEMPLATE INCLUDE : SharedCode.template.hlsl\n                    //-------------------------------------------------------------------------------------\n                   
      \n                    \n                        void BuildSurfaceData(FragInputs
      fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs
      posInput, out SurfaceData surfaceData)\n                        {\n                           
      // setup defaults -- these are used if the graph doesn't output a value\n                           
      ZERO_INITIALIZE(SurfaceData, surfaceData);\n                    \n                           
      // copy across graph values, if defined\n                            surfaceData.color
      = surfaceDescription.Color;\n                    \n                    #if
      defined(DEBUG_DISPLAY)\n                            if (_DebugMipMapMode !=
      DEBUGMIPMAPMODE_NONE)\n                            {\n                               
      // TODO\n                            }\n                    #endif\n                       
      }\n                    \n                        void GetSurfaceAndBuiltinData(FragInputs
      fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData,
      out BuiltinData builtinData)\n                        {\n                           
      SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs,
      V);\n            SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs,fragInputs.vparticle);\n                   
      \n                            // Perform alpha test very early to save performance
      (a killed pixel will not sample textures)\n                            // TODO:
      split graph evaluation to grab just alpha dependencies first? tricky..\n                           
      // DoAlphaTest(surfaceDescription.Alpha, surfaceDescription.AlphaClipThreshold);\n                   
      \n                            BuildSurfaceData(fragInputs, surfaceDescription,
      V, posInput, surfaceData);\n                    \n                           
      // Builtin Data\n                            ZERO_INITIALIZE(BuiltinData, builtinData);
      // No call to InitBuiltinData as we don't have any lighting\n                           
      builtinData.opacity = surfaceDescription.Alpha;\n                    \n                           
      builtinData.emissiveColor = surfaceDescription.Emission;\n                   
      \n                    #if (SHADERPASS == SHADERPASS_DISTORTION)\n                           
      builtinData.distortion = surfaceDescription.Distortion;\n                           
      builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                   
      #endif\n                        }\n                    \n                       
      //-------------------------------------------------------------------------------------\n                       
      // Pass Includes\n                        //-------------------------------------------------------------------------------------\n                           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForwardUnlit.hlsl\"\n                       
      //-------------------------------------------------------------------------------------\n                       
      // End Pass Includes\n                        //-------------------------------------------------------------------------------------\n                   
      \n                        \n            #define VFX_VARYING_PS_INPUTS VaryingsMeshToDS\n           
      #define VFX_VARYING_POSCS positionRWS\n            #include \"Packages/com.unity.visualeffectgraph/Shaders/RenderPipeline/HDRP/VFXCommon.cginc\"\n           
      #include \"Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.cginc\"\n           
      void SetAttribute_C707D62A(inout float3 position, float3 Position) /*attribute:position
      Composition:Add Source:Slot Random:Off channels:XYZ */\n            {\n               
      position += Position;\n            }\n            \n            PackedVaryingsType
      ParticleVert(AttributesMesh inputMesh)\n            {\n                uint
      index = inputMesh.particleID;\n                float size = asfloat(attributeBuffer.Load((index
      * 0x1 + 0x80) << 2));\n                float3 position = asfloat(attributeBuffer.Load3((index
      * 0x4 + 0xA0) << 2));\n                float3 color = float3(1,1,1);\n               
      float alpha = (float)1;\n                bool alive = (attributeBuffer.Load((index
      * 0x4 + 0xA3) << 2));\n                float3 axisX = float3(1,0,0);\n               
      float3 axisY = float3(0,1,0);\n                float3 axisZ = float3(0,0,1);\n               
      float angleX = (float)0;\n                float angleY = (float)0;\n               
      float angleZ = (float)0;\n                float pivotX = (float)0;\n               
      float pivotY = (float)0;\n                float pivotZ = (float)0;\n               
      float scaleX = (float)1;\n                float scaleY = (float)1;\n               
      float scaleZ = (float)1;\n                \n                float3 size3 =
      float3(size,size,size);\n                #if VFX_USE_SCALEX_CURRENT\n               
      size3.x *= scaleX;\n                #endif\n                #if VFX_USE_SCALEY_CURRENT\n               
      size3.y *= scaleY;\n                #endif\n                #if VFX_USE_SCALEZ_CURRENT\n               
      size3.z *= scaleZ;\n                #endif\n             SetAttribute_C707D62A(
      /*inout */position, Position_a);\n             \n                float4x4 elementToVFX
      = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),float3(pivotX,pivotY,pivotZ),size3,position);\n\n               
      float3 objectPos = inputMesh.positionOS;\n                float3 particlePos
      = mul(elementToVFX,float4(objectPos,1)).xyz;\n                inputMesh.positionOS
      = particlePos;\n                PackedVaryingsType result = Vert(inputMesh);\n\n               
      result.vmesh.particleID = inputMesh.particleID; // transmit the instanceID
      to the pixel shader through the varyings\n                return result;\n           
      }\n            #pragma vertex ParticleVert\n\n            ENDHLSL\n       
      }\n    }\n        }\n"
  m_Infos:
    m_Expressions:
      m_Expressions:
      - op: 1
        valueIndex: 0
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 1
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 2
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 3
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 4
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 5
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 6
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 7
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 8
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 9
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 10
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 11
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 12
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 13
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 14
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 15
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 16
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 17
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 18
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 19
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 20
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 21
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 22
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 23
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 24
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 25
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 26
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 27
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 28
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 29
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 30
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 31
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 3
        valueIndex: 32
        data[0]: 5
        data[1]: 8
        data[2]: 9
        data[3]: -1
      - op: 1
        valueIndex: 35
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 3
        valueIndex: 36
        data[0]: 27
        data[1]: 23
        data[2]: 19
        data[3]: -1
      - op: 1
        valueIndex: 39
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 20
        valueIndex: 40
        data[0]: 16
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 31
        valueIndex: 41
        data[0]: 17
        data[1]: 18
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 42
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 3
        valueIndex: 43
        data[0]: 20
        data[1]: 21
        data[2]: 24
        data[3]: -1
      - op: 3
        valueIndex: 46
        data[0]: 28
        data[1]: 25
        data[2]: 26
        data[3]: -1
      - op: 1
        valueIndex: 49
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 15
      - op: 1
        valueIndex: 50
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 6
      - op: 3
        valueIndex: 51
        data[0]: 22
        data[1]: 14
        data[2]: 13
        data[3]: -1
      - op: 3
        valueIndex: 54
        data[0]: 15
        data[1]: 11
        data[2]: 10
        data[3]: -1
      - op: 3
        valueIndex: 57
        data[0]: 29
        data[1]: 12
        data[2]: 1
        data[3]: -1
      - op: 1
        valueIndex: 60
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 61
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 3
        valueIndex: 62
        data[0]: 7
        data[1]: 6
        data[2]: 0
        data[3]: -1
      - op: 1
        valueIndex: 65
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 6
        valueIndex: 66
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: -1
      - op: 3
        valueIndex: 67
        data[0]: 4
        data[1]: 3
        data[2]: 2
        data[3]: -1
      - op: 1
        valueIndex: 70
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 71
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      - op: 1
        valueIndex: 72
        data[0]: -1
        data[1]: -1
        data[2]: -1
        data[3]: 1
      m_NeedsLocalToWorld: 0
      m_NeedsWorldToLocal: 0
      m_NeededMainCameraBuffers: 0
    m_PropertySheet:
      m_Float:
        m_Array:
        - m_ExpressionIndex: 0
          m_Value: 0
        - m_ExpressionIndex: 1
          m_Value: 0
        - m_ExpressionIndex: 2
          m_Value: 0
        - m_ExpressionIndex: 3
          m_Value: 0
        - m_ExpressionIndex: 4
          m_Value: -3.8
        - m_ExpressionIndex: 5
          m_Value: 0.8
        - m_ExpressionIndex: 6
          m_Value: 0
        - m_ExpressionIndex: 7
          m_Value: 0
        - m_ExpressionIndex: 8
          m_Value: 0
        - m_ExpressionIndex: 9
          m_Value: 0
        - m_ExpressionIndex: 10
          m_Value: 0.333
        - m_ExpressionIndex: 11
          m_Value: 1
        - m_ExpressionIndex: 12
          m_Value: 0
        - m_ExpressionIndex: 13
          m_Value: -0.333
        - m_ExpressionIndex: 14
          m_Value: 0.2
        - m_ExpressionIndex: 15
          m_Value: 0.333
        - m_ExpressionIndex: 16
          m_Value: 0.2928932
        - m_ExpressionIndex: 17
          m_Value: 10
        - m_ExpressionIndex: 18
          m_Value: 0
        - m_ExpressionIndex: 19
          m_Value: 0
        - m_ExpressionIndex: 20
          m_Value: 0
        - m_ExpressionIndex: 21
          m_Value: 1
        - m_ExpressionIndex: 22
          m_Value: -0.333
        - m_ExpressionIndex: 23
          m_Value: 0
        - m_ExpressionIndex: 24
          m_Value: 0
        - m_ExpressionIndex: 25
          m_Value: 3
        - m_ExpressionIndex: 26
          m_Value: 2
        - m_ExpressionIndex: 27
          m_Value: 3.8
        - m_ExpressionIndex: 28
          m_Value: 2
        - m_ExpressionIndex: 29
          m_Value: -0.8
        - m_ExpressionIndex: 30
          m_Value: 1.23
        - m_ExpressionIndex: 31
          m_Value: 0
        - m_ExpressionIndex: 33
          m_Value: 0
        - m_ExpressionIndex: 35
          m_Value: -1.21
        - m_ExpressionIndex: 38
          m_Value: -2.63
        - m_ExpressionIndex: 46
          m_Value: 1
        - m_ExpressionIndex: 47
          m_Value: 0.59
        - m_ExpressionIndex: 49
          m_Value: 2.63
        - m_ExpressionIndex: 52
          m_Value: -4.16
        - m_ExpressionIndex: 53
          m_Value: 3
        - m_ExpressionIndex: 54
          m_Value: 4.16
      m_Vector2f:
        m_Array: []
      m_Vector3f:
        m_Array: []
      m_Vector4f:
        m_Array: []
      m_Uint:
        m_Array:
        - m_ExpressionIndex: 42
          m_Value: 4294967295
      m_Int:
        m_Array: []
      m_Matrix4x4f:
        m_Array: []
      m_AnimationCurve:
        m_Array: []
      m_Gradient:
        m_Array: []
      m_NamedObject:
        m_Array:
        - m_ExpressionIndex: 41
          m_Value: {fileID: 10208, guid: 0000000000000000e000000000000000, type: 0}
      m_Bool:
        m_Array: []
    m_ExposedExpressions: []
    m_Buffers:
    - type: 1
      size: 320
      layout:
      - name: velocity
        type: 3
        offset:
          bucket: 0
          structure: 4
          element: 0
      - name: lifetime
        type: 1
        offset:
          bucket: 0
          structure: 4
          element: 3
      - name: size
        type: 1
        offset:
          bucket: 128
          structure: 1
          element: 0
      - name: position
        type: 3
        offset:
          bucket: 160
          structure: 4
          element: 0
      - name: alive
        type: 17
        offset:
          bucket: 160
          structure: 4
          element: 3
      - name: age
        type: 1
        offset:
          bucket: 288
          structure: 1
          element: 0
      capacity: 32
      stride: 4
    - type: 1
      size: 320
      layout:
      - name: velocity
        type: 3
        offset:
          bucket: 0
          structure: 4
          element: 0
      - name: lifetime
        type: 1
        offset:
          bucket: 0
          structure: 4
          element: 3
      - name: size
        type: 1
        offset:
          bucket: 128
          structure: 1
          element: 0
      - name: position
        type: 3
        offset:
          bucket: 160
          structure: 4
          element: 0
      - name: alive
        type: 17
        offset:
          bucket: 160
          structure: 4
          element: 3
      - name: age
        type: 1
        offset:
          bucket: 288
          structure: 1
          element: 0
      capacity: 32
      stride: 4
    - type: 1
      size: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      capacity: 1
      stride: 4
    - type: 4
      size: 32
      layout: []
      capacity: 0
      stride: 4
    - type: 1
      size: 1
      layout: []
      capacity: 0
      stride: 4
    m_TemporaryBuffers: []
    m_CPUBuffers:
    - capacity: 1
      stride: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      initialData:
        data: 00000000
    - capacity: 1
      stride: 1
      layout:
      - name: spawnCount
        type: 1
        offset:
          bucket: 0
          structure: 1
          element: 0
      initialData:
        data: 00000000
    m_Events:
    - name: OnPlay
      playSystems: 00000000
      stopSystems: 
    - name: OnStop
      playSystems: 
      stopSystems: 00000000
    m_RuntimeVersion: 10
    m_RendererSettings:
      motionVectorGenerationMode: 0
      shadowCastingMode: 0
      receiveShadows: 0
      reflectionProbeUsage: 0
      lightProbeUsage: 0
    m_CullingFlags: 3
    m_UpdateMode: 0
    m_PreWarmDeltaTime: 0.05
    m_PreWarmStepCount: 0
    m_InitialEventName: OnPlay
  m_Systems:
  - type: 0
    flags: 0
    capacity: 0
    layer: 4294967295
    buffers:
    - nameId: spawner_output
      index: 1
    values: []
    tasks:
    - type: 268435456
      buffers: []
      temporaryBuffers: []
      values:
      - nameId: Rate
        index: 37
      params: []
      processor: {fileID: 0}
      shaderSourceIndex: -1
  - type: 1
    flags: 1
    capacity: 32
    layer: 4294967295
    buffers:
    - nameId: attributeBuffer
      index: 0
    - nameId: sourceAttributeBuffer
      index: 2
    - nameId: deadList
      index: 3
    - nameId: deadListCount
      index: 4
    - nameId: spawner_input
      index: 1
    values:
    - nameId: bounds_center
      index: 39
    - nameId: bounds_size
      index: 40
    tasks:
    - type: 536870912
      buffers:
      - nameId: attributeBuffer
        index: 0
      - nameId: deadListIn
        index: 3
      - nameId: deadListCount
        index: 4
      - nameId: sourceAttributeBuffer
        index: 2
      temporaryBuffers: []
      values:
      - nameId: A_a
        index: 43
      - nameId: B_a
        index: 44
      - nameId: A_b
        index: 46
      - nameId: B_b
        index: 53
      - nameId: Size_c
        index: 47
      - nameId: Position_d
        index: 48
      params:
      - nameId: bounds_center
        index: 39
      - nameId: bounds_size
        index: 40
      processor: {fileID: 0}
      shaderSourceIndex: 0
    - type: 805306368
      buffers:
      - nameId: attributeBuffer
        index: 0
      - nameId: deadListOut
        index: 3
      temporaryBuffers: []
      values:
      - nameId: deltaTime_a
        index: 50
      params: []
      processor: {fileID: 0}
      shaderSourceIndex: 1
    - type: 1073741826
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values:
      - nameId: Position_a
        index: 51
      - nameId: Vector1_4B24F63
        index: 52
      - nameId: Vector1_9B1964B1
        index: 38
      params:
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 2
    - type: 1073741829
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values:
      - nameId: Position_a
        index: 45
      - nameId: Vector1_4B24F63
        index: 35
      - nameId: Vector1_9B1964B1
        index: 33
      params:
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 3
    - type: 1073741830
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values:
      - nameId: Position_a
        index: 32
      - nameId: Vector1_4B24F63
        index: 30
      - nameId: Vector1_9B1964B1
        index: 31
      - nameId: cropFactor
        index: 36
      params:
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 4
    - type: 1073741828
      buffers:
      - nameId: attributeBuffer
        index: 0
      temporaryBuffers: []
      values:
      - nameId: Position_a
        index: 34
      - nameId: Vector1_4B24F63
        index: 49
      - nameId: Vector1_9B1964B1
        index: 54
      params:
      - nameId: mesh
        index: 41
      - nameId: subMeshMask
        index: 42
      - nameId: sortPriority
        index: 0
      processor: {fileID: 0}
      shaderSourceIndex: 5
--- !u!114 &8926484042661614541
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a9f9544b71b7dab44a4644b6807e8bf6, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614542}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614541}
  m_MasterData:
    m_Owner: {fileID: 114206037049139666}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Vector, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"vector":{"x":-0.3330000042915344,"y":0.20000000298023225,"z":-0.3330000042915344}}'
    m_Space: 0
  m_Property:
    name: A
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Vector, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614542
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614541}
  m_Children:
  - {fileID: 8926484042661614543}
  - {fileID: 8926484042661614544}
  - {fileID: 8926484042661614545}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614541}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: vector
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The vector.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614543
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614542}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614541}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614544
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614542}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614541}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614545
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614542}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614541}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614546
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a9f9544b71b7dab44a4644b6807e8bf6, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614547}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614546}
  m_MasterData:
    m_Owner: {fileID: 114206037049139666}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Vector, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"vector":{"x":0.3330000042915344,"y":1.0,"z":0.3330000042915344}}'
    m_Space: 0
  m_Property:
    name: B
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Vector, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614547
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614546}
  m_Children:
  - {fileID: 8926484042661614548}
  - {fileID: 8926484042661614549}
  - {fileID: 8926484042661614550}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614546}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: vector
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The vector.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614548
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614547}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614546}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614549
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614547}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614546}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614550
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614547}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614546}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614551
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614551}
  m_MasterData:
    m_Owner: {fileID: 114131763552434164}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1
    m_Space: 2147483647
  m_Property:
    name: A
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614552
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614552}
  m_MasterData:
    m_Owner: {fileID: 114131763552434164}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 3
    m_Space: 2147483647
  m_Property:
    name: B
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614554
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a3006faa3d2c7044f9fd845cf4bf9333, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614591}
  m_UIPosition: {x: 363, y: 806}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614643}
  - {fileID: 8926484042661614644}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: e7c0a55dd148ab04e9d7a968ae530baa,
    type: 3}
  primitiveType: 1
--- !u!114 &8926484042661614566
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a3006faa3d2c7044f9fd845cf4bf9333, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614637}
  m_UIPosition: {x: 765, y: 804}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614645}
  - {fileID: 8926484042661614646}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: e7c0a55dd148ab04e9d7a968ae530baa,
    type: 3}
  primitiveType: 0
--- !u!114 &8926484042661614578
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a3006faa3d2c7044f9fd845cf4bf9333, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614631}
  m_UIPosition: {x: 1164, y: 810}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614647}
  - {fileID: 8926484042661614648}
  - {fileID: 8926484042661614590}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: e7c0a55dd148ab04e9d7a968ae530baa,
    type: 3}
  primitiveType: 2
--- !u!114 &8926484042661614590
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614590}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614578}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0.2928932
    m_Space: 2147483647
  m_Property:
    name: cropFactor
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 0
      m_Min: 0
      m_Max: 1
      m_Tooltip: 
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614591
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614554}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614592}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614592
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614593}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614592}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614591}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":-3.799999952316284,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614593
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614592}
  m_Children:
  - {fileID: 8926484042661614594}
  - {fileID: 8926484042661614595}
  - {fileID: 8926484042661614596}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614592}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614594
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614593}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614592}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614595
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614593}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614592}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614596
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614593}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614592}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614603
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114946465509916290}
  m_Children: []
  m_UIPosition: {x: 0, y: 186}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614604}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: size
  Composition: 0
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614604
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614604}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614603}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 0.59
    m_Space: 2147483647
  m_Property:
    name: Size
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614605
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114946465509916290}
  m_Children: []
  m_UIPosition: {x: 0, y: 261}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614606}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 0
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614606
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614607}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614605}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.0,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614607
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614606}
  m_Children:
  - {fileID: 8926484042661614608}
  - {fileID: 8926484042661614609}
  - {fileID: 8926484042661614610}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614608
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614607}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614609
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614607}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614610
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614607}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614606}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614611
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f4476dfd621f4fe428fe6e72d10aa015, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 114350483966674976}
  m_Children:
  - {fileID: 8926484042661614625}
  m_UIPosition: {x: 1567, y: 814}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614649}
  - {fileID: 8926484042661614650}
  - {fileID: 8926484042661614612}
  - {fileID: 8926484042661614613}
  m_OutputSlots: []
  m_Label: 
  m_Data: {fileID: 114428730288789306}
  m_InputFlowSlot:
  - link:
    - context: {fileID: 114780028408030698}
      slotIndex: 0
  m_OutputFlowSlot:
  - link: []
  useSoftParticle: 0
  sortPriority: 0
  castShadows: 0
  m_ShaderGraph: {fileID: -6465566751694194690, guid: e7c0a55dd148ab04e9d7a968ae530baa,
    type: 3}
--- !u!114 &8926484042661614612
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b47b8679b468b7347a00cdd50589bc9f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614612}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614611}
    m_Value:
      m_Type:
        m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
          Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"obj":{"fileID":10208,"guid":"0000000000000000e000000000000000","type":0}}'
    m_Space: 2147483647
  m_Property:
    name: mesh
    m_serializedType:
      m_SerializableType: UnityEngine.Mesh, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Mesh to be used for particle rendering.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614613
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c52d920e7fff73b498050a6b3c4404ca, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614613}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614611}
    m_Value:
      m_Type:
        m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 4294967295
    m_Space: 2147483647
  m_Property:
    name: subMeshMask
    m_serializedType:
      m_SerializableType: System.UInt32, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: Define a bitmask to control which submeshes are rendered.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614625
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614611}
  m_Children: []
  m_UIPosition: {x: -282.5, y: -194}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614626}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614626
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614627}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614626}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614625}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":3.799999952316284,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614627
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614626}
  m_Children:
  - {fileID: 8926484042661614628}
  - {fileID: 8926484042661614629}
  - {fileID: 8926484042661614630}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614626}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614628
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614627}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614626}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614629
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614627}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614626}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614630
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614627}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614626}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614631
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614578}
  m_Children: []
  m_UIPosition: {x: -282.5, y: -194}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614632}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614632
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614633}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614632}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614631}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":0.800000011920929,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614633
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614632}
  m_Children:
  - {fileID: 8926484042661614634}
  - {fileID: 8926484042661614635}
  - {fileID: 8926484042661614636}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614632}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614634
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614633}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614632}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614635
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614633}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614632}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614636
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614633}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614632}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614637
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a971fa2e110a0ac42ac1d8dae408704b, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614566}
  m_Children: []
  m_UIPosition: {x: -282.5, y: -194}
  m_UICollapsed: 0
  m_UISuperCollapsed: 0
  m_InputSlots:
  - {fileID: 8926484042661614638}
  m_OutputSlots: []
  m_Disabled: 0
  attribute: position
  Composition: 1
  Source: 0
  Random: 0
  channels: 6
--- !u!114 &8926484042661614638
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5265657162cc1a241bba03a3b0476d99, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children:
  - {fileID: 8926484042661614639}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614638}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614637}
    m_Value:
      m_Type:
        m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
          Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
      m_SerializableObject: '{"position":{"x":-0.800000011920929,"y":0.0,"z":0.0}}'
    m_Space: 0
  m_Property:
    name: Position
    m_serializedType:
      m_SerializableType: UnityEditor.VFX.Position, Unity.VisualEffectGraph.Editor,
        Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614639
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ac39bd03fca81b849929b9c966f1836a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614638}
  m_Children:
  - {fileID: 8926484042661614640}
  - {fileID: 8926484042661614641}
  - {fileID: 8926484042661614642}
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614638}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: position
    m_serializedType:
      m_SerializableType: UnityEngine.Vector3, UnityEngine.CoreModule, Version=0.0.0.0,
        Culture=neutral, PublicKeyToken=null
    attributes:
    - m_Type: 3
      m_Min: -Infinity
      m_Max: Infinity
      m_Tooltip: The position.
      m_Regex: 
      m_RegexMaxLength: 0
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614640
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614639}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614638}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: x
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614641
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614639}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614638}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: y
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614642
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 8926484042661614639}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614638}
  m_MasterData:
    m_Owner: {fileID: 0}
    m_Value:
      m_Type:
        m_SerializableType: 
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: z
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614643
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614643}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614554}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: -4.16
    m_Space: 2147483647
  m_Property:
    name: Vector1_4B24F63
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614644
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614644}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614554}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: -2.63
    m_Space: 2147483647
  m_Property:
    name: Vector1_9B1964B1
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614645
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614645}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614566}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: -1.21
    m_Space: 2147483647
  m_Property:
    name: Vector1_4B24F63
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614646
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614646}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614566}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: Vector1_9B1964B1
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614647
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614647}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614578}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 1.23
    m_Space: 2147483647
  m_Property:
    name: Vector1_4B24F63
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614648
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614648}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614578}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 
    m_Space: 2147483647
  m_Property:
    name: Vector1_9B1964B1
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614649
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614649}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614611}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 2.63
    m_Space: 2147483647
  m_Property:
    name: Vector1_4B24F63
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
--- !u!114 &8926484042661614650
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f780aa281814f9842a7c076d436932e7, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Parent: {fileID: 0}
  m_Children: []
  m_UIPosition: {x: 0, y: 0}
  m_UICollapsed: 1
  m_UISuperCollapsed: 0
  m_MasterSlot: {fileID: 8926484042661614650}
  m_MasterData:
    m_Owner: {fileID: 8926484042661614611}
    m_Value:
      m_Type:
        m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
          PublicKeyToken=b77a5c561934e089
      m_SerializableObject: 4.16
    m_Space: 2147483647
  m_Property:
    name: Vector1_9B1964B1
    m_serializedType:
      m_SerializableType: System.Single, mscorlib, Version=4.0.0.0, Culture=neutral,
        PublicKeyToken=b77a5c561934e089
    attributes: []
  m_Direction: 0
  m_LinkedSlots: []
