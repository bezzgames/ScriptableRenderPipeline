// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KMain
#pragma kernel KMainMSAA

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"

RW_TEXTURE2D(float4, _OutputTexture);
TEXTURE2D_X(_InputTexture);
TEXTURE2D_X_MSAA(float4, _InputTextureMSAA);

CBUFFER_START(cb0)
    float4 _Params;
CBUFFER_END

#define Scale            _Params.x
#define startOffsetX     _Params.y
#define startOffsetY     _Params.z

static const uint TGSize = 8;

[numthreads(TGSize, TGSize, 1)]
void KMain(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint2 samplePos = dispatchThreadId.xy;
    const uint2 startOffset = uint2(startOffsetX, startOffsetY);
    const uint2 offset = (startOffset + samplePos) % Scale;

    float4 value = LOAD_TEXTURE2D_X(_InputTexture, samplePos * Scale + offset);
    _OutputTexture[samplePos] = value;
}

[numthreads(TGSize, TGSize, 1)]
void KMainMSAA(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint2 samplePos = dispatchThreadId.xy;
    const uint2 startOffset = uint2(startOffsetX, startOffsetY);
    const uint2 offset = (startOffset + samplePos) % Scale;

    float4 value = LOAD_TEXTURE2D_X_MSAA(_InputTextureMSAA, samplePos * Scale + offset, 0);
    _OutputTexture[samplePos] = value;
}
